 1/1:
int f = input()
print(f)
 1/2:
f = input(string)
print(f)
 1/3:
f = input(int)
print(f)
 1/4:
f = input(str)
print(f)
 1/5:
a = input(int)
b = input(int)
print(a+b)
 1/6:
a = input(int)
b = input(int)
c = a + b
print(c)
 1/7:
a = input(int)
b = input(int)
c = a.add(b)
print(c)
 1/8:
a = input(int)
b = input(int)
print(int(a) + int(b))
 1/9:
print("Number 1")
a = input(int)
print("Number 2")
b = input(int)
print(int(a) + int(b))
1/10:
print("input word")
a = input(str)
for c in a:
    print(c)
1/11:
print("input word")
a = input(str)
for c in a:
    print(c)
1/12:
print("input word")
a = input(str)
a.replace("o","")
for c in a:
    print(c)
1/13:
print("input word")
a = input(str)
a = a.replace("o","")
for c in a:
    print(c)
1/14:
print("input word")
a = input(str)
a = a.replace("lo","")
for c in a:
    print(c)
1/15:
print("input word")
a = input(str)
a = a.replace(" ","_")
for c in a:
    print(c)
1/16:
print("input word")
a = input(str)
a = a.replace(" ","_")
for c in a:
    print(c)
print(a)
 2/1:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len[brks]-1] + mean(diff(brks))]
    return brks
 2/2:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len[brks]-1] + mean(diff(brks))]
    return brks
 2/3: print(fixBreaks([10,20],[1,2]))
 2/4: brk = [1,2,3,4,5,6,7,8,9,10]
 2/5: brk = [1,2,3,4,5,6,7,8,9,10]
 2/6: print(fixBreaks(brks,rngin))
 2/7:
brk = [1,2,3,4,5,6,7,8,9,10]
rngin = [min([10, 11, 12, 75, 77, 78, 79, 41, 42, 44]),max([10, 11, 12, 75, 77, 78, 79, 41, 42, 44])]
 2/8:
brk = [1,2,3,4,5,6,7,8,9,10]
rngin = [min([10, 11, 12, 75, 77, 78, 79, 41, 42, 44]),max([10, 11, 12, 75, 77, 78, 79, 41, 42, 44])]
print(brk)
print(rngin)
 2/9: print(fixBreaks(brks,rngin))
2/10: print(fixBreaks(brk,rngin))
2/11:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        print(1)
    return brks
2/12:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        print(1)
    return brks
2/13:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len[brks]-1] + mean(diff(brks))]
    return brks
2/14:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len[brks]-1] + mean(diff(brks))]
    return brks
2/15: print(fixBreaks(brk,rngin))
2/16:
def diff(x):
    counter = 0
    out = []
    while counter < len(x)-1:
        out.append(x[counter+1]-x[counter])
        counter += 1
    return out
2/17:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len[brks]-1] + mean(diff(brks))]
    return brks
2/18: (rngin[1]+1e-6),brk[len[brk]-1] + mean(diff(brk))
2/19: (rngin[1]+1e-6)
2/20: brk[len[brk]-1] + mean(diff(brk))
2/21: brk[len[brk]-1]
2/22: brk[len(brk)-1]
2/23: brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + mean(diff(brks))]
2/24:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + mean(diff(brks))]
    return brks
2/25: print(fixBreaks(brk,rngin))
2/26: import math
2/27: brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + math.mean(diff(brks))]
2/28:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + math.mean(diff(brks))]
    return brks
2/29: print(fixBreaks(brk,rngin))
2/30:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + statistics.mean(diff(brks))]
    return brks
2/31: print(fixBreaks(brk,rngin))
2/32:
import math
import statistics
2/33:
def fixBreaks(brks, rng):
    print(len(brks),rng[1])
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + statistics.mean(diff(brks))]
    return brks
2/34: print(fixBreaks(brk,rngin))
2/35:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
2/36:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
2/37:
def group_mz_values(x,mzd,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    print("mzdiff")
    print(mzdiff)
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            print(mzdiff[counter])
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        print("")
        print(input_array)
        return cumsum(input_array)
2/38:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
2/39:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
2/40:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
2/41:
def dotProduct(x,y):

    pass
2/42:
def compareSpectra(a,b):

    pass
2/43:
def binSpectra(x,y):
    holder = []
    holder = x.mz
    holder.append(y.mx)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/44:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)

    pass
2/45:
def binValues(ints,mzs,brks):
    try:
        breaks = fixBreaks(brks,[min(x.mz),max(x.mz)])
        nbrks = [min(breaks),max(breaks)]
        idx = findInterval(mzs,breaks)

        iints = []
        for i in range(1,len(nbrks)+1):
            iints.append(0)


    except:
        pass
2/46:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    return out
2/47:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 44],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/48: print(binSpectra(s1,s2))
2/49: print(binSpectra(s1,s2))
2/50:
def binSpectra(x,y):
    holder = []
    holder = x.mz
    holder.append(y.mz)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/51: print(binSpectra(s1,s2))
2/52:
def binSpectra(x,y):
    holder = []
    holder = x.mz
    holder.append(y.mz)
    print(holder)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/53:
def binSpectra(x,y):
    holder = []
    holder = x.mz
    holder.append(y.mz)
    print(holder)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/54: print(binSpectra(s1,s2))
2/55:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/56: print(binSpectra(s1,s2))
2/57:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(x.mz)
    print(y.mz)
    print(holder)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/58: print(binSpectra(s1,s2))
2/59: print(binSpectra(s1,s2))
2/60:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(x.mz)
    print("----")
    print(y.mz)
    print(holder)

    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/61: print(binSpectra(s1,s2))
2/62:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 44],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/63: print(binSpectra(s1,s2))
2/64: print(binValues(s1.intensity,s1.mz,brk))
2/65: breaks = fixBreaks(brks,[min(mzs),max(mzs)])
2/66: breaks = fixBreaks(brk,[min(mzs),max(mzs)])
2/67:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
2/68: nbrks = [min(breaks),max(breaks)]
2/69:
import math
import statistics
2/70:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        brks = [brks,(rng[1]+1e-6),brks[len(brks)-1] + statistics.mean(diff(brks))]
    return brks
2/71:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/72:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        brks.append(rng[1]+1e-6)
        brks.append(brks[len(brks)-1] + statistics.mean(diff(brks)))
    return brks
2/73:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/74:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/75:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/76:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 44],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/77:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/78:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(rng[1]+1e-6)
        out.append(brks[len(brks)-1] + statistics.mean(diff(brks)))
    return out
2/79:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 44],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/80:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/81:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/82:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/83:
def binValues(ints,mzs,brks):
    try:
        breaks = fixBreaks(brks,[min(mzs),max(mzs)])
        nbrks = [min(breaks),max(breaks)]
        idx = findInterval(mzs,breaks)

        iints = []
        for i in range(1,len(nbrks)+1):
            iints.append(0)

    except:
        pass
2/84:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max(rng[1]+1e-6),brks[len(brks)-1] + statistics.mean(diff(brks)))
    return out
2/85:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/86:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max((rng[1]+1e-6),brks[len(brks)-1] + statistics.mean(diff(brks)))
    return out
2/87:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))])
    return out
2/88:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
    return out
2/89:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/90:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
    return out
2/91:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
2/92:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/93:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
2/94:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/95:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        print(out)
        print(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
2/96:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/97:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/98:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/99:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/100:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/101:
mzs = s1.mz
breaks = fixBreaks(brk,[min(mzs),max(mzs)])
print(breaks)
2/102: nbrks = [min(breaks),max(breaks)]
2/103: nbrks = [min(breaks),max(breaks)]
2/104:
nbrks = [min(breaks),max(breaks)]
print(nbrks)
2/105:
nbrks = len(breaks)
print(nbrks)
2/106: idx = findInterval(mzs,breaks)
2/107:
idx = findInterval(mzs,breaks)
print(idx)
2/108:
def binValues(ints,mzs,brks):
    try:
        breaks = fixBreaks(brks,[min(mzs),max(mzs)])
        nbrks = len(breaks)
        idx = findInterval(mzs,breaks)

        iints = []
        for i in range(1,len(nbrks)+1):
            iints.append(0)

    except:
        pass
2/109:
iints = []
    for i in range(1,len(nbrks)+1):
        iints.append(0)
print(iints)
2/110:
iints = []
for i in range(1,len(nbrks)+1):
    iints.append(0)
print(iints)
2/111:
iints = []
for i in range(1,nbrks+1):
    iints.append(0)
print(iints)
2/112:
iints = []
for i in range(1,nbrks):
    iints.append(0)
print(iints)
2/113:
aa = [1,2,3,4]  


for i in aa:  
    print(i, end="" )
2/114: print(split(brk,brk))
2/115:
print(brk)
print(split(brk,brk))
2/116:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/117:
print(brk)
print(split(brk,brk))
2/118:
s = split(ints,idx)
print(s)
2/119:
s = split(s1.intensity,idx)
print(s)
2/120:
s = split(s1.intensity,idx)
s = list(s)
print(s)
2/121:
s = split(s1.intensity,idx)
print(s)
s = list(s)
print(s)
2/122:
s = split(s1.intensity,idx)
for j in split:
    print(j)
2/123:
s = split(s1.intensity,idx)
for j,h in split:
    print(j)
2/124:
s = split(s1.intensity,idx)
for j,h in s:
    print(j)
2/125:
s = split(s1.intensity,idx)
for j in s:
    print(j)
2/126:
s = split(s1.intensity,idx)
for j in s:
    print(s[j[])
2/127:
s = split(s1.intensity,idx)
for j in s:
    print(s[j])
2/128:
s = split(s1.intensity,idx)
for j in s:
    s[j] = max(s[j])
2/129:
s = split(s1.intensity,idx)
for j in s:
    s[j] = max(s[j])
print(s)
2/130:
s = split(s1.intensity,idx)
for j in s:
    s[j] = max(s[j])
for i in s:
     iints[i] = s[i]
        
print(iints)
2/131:
s = split(s1.intensity,idx)
for j in s:
    s[j] = max(s[j])
for i in s:
     iints[i-1] = s[i]
        
print(iints)
2/132:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/133: brk
2/134: brk.append(11)
2/135: brk
2/136:
iints = brk
counter = 0
out = []
while counter < len(brk):
    out.append(statistics.mean([iints[counter],iints[counter+1]]))
    counter += 1
print(out)
2/137:
iints = brk
counter = 0
out = []
while counter < len(brk):
    try:
        out.append(statistics.mean([iints[counter],iints[counter+1]]))
    except:
        pass
    counter += 1
print(out)
2/138:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)

    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
        
    return out
2/139: print(binValues(s1.intensity,s1.mz,brk))
2/140: print(binValues(s1.intensity,s1.mz,brk))
2/141: print(binValues(s1.intensity,s1.mz,brk))
2/142: print(binValues(s1.intensity,s1.mz,brk))
2/143:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/144: print(binValues(s1.intensity,s1.mz,brk))
2/145: print(binValues(s1.intensity,s1.mz,brk))
2/146:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/147: print(binValues(s1.intensity,s1.mz,brk))
2/148:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/149: print(binValues(s1.intensity,s1.mz,brk))
2/150: print(binValues(s1.intensity,s1.mz,brk))
2/151:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/152: print(binValues(s1.intensity,s1.mz,brk))
2/153:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/154: print(binValues(s1.intensity,s1.mz,brk))
2/155: print(binValues(s1.intensity,s1.mz,brk))
2/156:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/157: print(binValues(s1.intensity,s1.mz,brk))
2/158:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)

    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    print(out)
    
    return out
2/159: print(binValues(s1.intensity,s1.mz,brk))
2/160:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/161: print(binValues(s1.intensity,s1.mz,brk))
2/162:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/163: print(binValues(s1.intensity,s1.mz,brk))
2/164:
def binValues(ints,mzs,brks):
    print(1)
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)

    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/165:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/166: print(binValues(s1.intensity,s1.mz,brk))
2/167:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/168: print(binValues(s1.intensity,s1.mz,brk))
2/169:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/170:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    print(1)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/171: print(binValues(s1.intensity,s1.mz,brk))
2/172:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    print(1)
    s = split(ints,idx)
    print(1)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/173:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/174: print(binValues(s1.intensity,s1.mz,brk))
2/175:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    print(1)
    for i in range(1,nbrks):
        iints.append(0)
    print(1)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/176:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/177: print(binValues(s1.intensity,s1.mz,brk))
2/178:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/179: print(binValues(s1.intensity,s1.mz,brk))
2/180:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    print(1)
    idx = findInterval(mzs,breaks)
    iints = []
    print(1)
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/181:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/182: print(binValues(s1.intensity,s1.mz,brk))
2/183:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(1)
    nbrks = len(breaks)
    print(1)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/184:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/185:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(1)
    nbrks = len(breaks)
    print(1)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/186: print(binValues(s1.intensity,s1.mz,brk))
2/187:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
2/188:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/189:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(1)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/190: print(binValues(s1.intensity,s1.mz,brk))
2/191:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    counter = 0
    out = []
    while counter < len(brk):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/192:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/193: print(binValues(s1.intensity,s1.mz,brk))
2/194: print(binValues(s1.intensity,s1.mz,brk))
2/195:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/196: print(binValues(s1.intensity,s1.mz,brk))
2/197: print(binValues(s1.intensity,s1.mz,brk))
2/198: print(binValues(s1.intensity,s1.mz,brk))
2/199: print(binValues(s1.intensity,s1.mz,brk))
2/200: print(binValues(s1.intensity,s1.mz,brk))
2/201:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/202:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = []
    while counter < len(iints):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/203: print(binValues(s1.intensity,s1.mz,brk))
2/204:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(break)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = []
    while counter < len(iints):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/205:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = []
    while counter < len(iints):
        try:
            out.append(statistics.mean([iints[counter],iints[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/206: print(binValues(s1.intensity,s1.mz,brk))
2/207:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/208: print(binValues(s1.intensity,s1.mz,brk))
2/209:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    while counter < len(iints):
        try:
            out[x] = out[x].append([iints[counter])
            out[mid] = out[mid].append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/210:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    while counter < len(iints):
        try:
            out[x] = out[x].append(iints[counter])
            out[mid] = out[mid].append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/211: print(binValues(s1.intensity,s1.mz,brk))
2/212:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    while counter < len(iints):
        try:
            out["x"] = out["x"].append(iints[counter])
            out["mid"] = out["mid"].append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/213: print(binValues(s1.intensity,s1.mz,brk))
2/214:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    
    
    return out
2/215:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/216: print(binValues(s1.intensity,s1.mz,brk))
2/217:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([10, 11, 12, 75, 77, 78, 79, 41, 42, 45],[3, 30, 5, 15, 12, 70, 18, 6, 4, 22])
2/218:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(breaks)
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    counter = 0
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/219: print(binValues(s1.intensity,s1.mz,brk))
2/220:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/221: print(binValues(s2.intensity,s2.mz,brk))
2/222:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([iints[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/223:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/224:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/225: print(binValues(s2.intensity,s2.mz,brk))
2/226:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/227: print(binValues(s2.intensity,s2.mz,brk))
2/228:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/229: print(binValues(s2.intensity,s2.mz,brk))
2/230:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/231:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])

    pass
2/232: print(binSpectrum(s1,brk))
2/233:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
2/234:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/235: print(binSpectrum(s1,brk))
2/236: print(binSpectra(s1,s2))
2/237:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/238:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
2/239:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    return out
2/240:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
2/241:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
2/242:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
2/243:
def group_mz_values(x,mzd,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
2/244:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
2/245:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
2/246: print(binSpectra(s1,s2))
2/247:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/248: print(binSpectra(s1,s2))
2/249:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/250: print(binSpectra(s1,s2))
2/251: print(binSpectra(s1,s2))
2/252: print(binSpectra(s1,s2))
2/253: print(binSpectra(s1,s2))
2/254: print(binSpectra(s1,s2))
2/255: print(binSpectra(s1,s2))
2/256: print(binSpectra(s1,s2))
2/257: print(binSpectra(s1,s2))
2/258: print(binSpectra(s1,s2))
2/259: print(binSpectra(s1,s2))
2/260: print(binSpectra(s1,s2))
2/261: print(binSpectra(s1,s2))
2/262:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/263: print(binSpectra(s1,s2))
2/264: print(binSpectra(s1,s2))
2/265:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
            print(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/266: print(binSpectra(s1,s2))
2/267:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            print(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/268: print(binSpectra(s1,s2))
2/269:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(s[i])
        
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/270: print(binSpectra(s1,s2))
2/271:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(iints[i-1])
        
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/272: print(binSpectra(s1,s2))
2/273:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(iints[i-1])
        
        
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/274: print(binSpectra(s1,s2))
2/275:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(iints[i-1])
        
    print(iints[0])
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/276: print(binSpectra(s1,s2))
2/277:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(iints[i-1])
        
    print(iints[10])
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/278: print(binSpectra(s1,s2))
2/279:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        print(iints[i-1])
        
    print(iints[9])
    print(iints)
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/280: print(binSpectra(s1,s2))
2/281:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s)
        print(1)
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/282:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s):
        print("jd")
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/283: print(binSpectra(s1,s2))
2/284:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s):
        print("jd")
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/285: print(binSpectra(s1,s2))
2/286:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s):
        print(iints[len(iints)])
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/287: print(binSpectra(s1,s2))
2/288:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s):
        print(iints[len(iints)-1])
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/289: print(binSpectra(s1,s2))
2/290:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    if len(iints) > len(s):
        iints.pop()
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/291: print(binSpectra(s1,s2))
2/292:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    pass
2/293:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten["1"] = i["intensity"]
    
    print(inten)
2/294: print(compareSpectra(s1,s2))
2/295:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    return inten
2/296: print(compareSpectra(s1,s2))
2/297:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    out = dotproduct(inten)
    return out
2/298:
import math
import statistics
import numpy as np
2/299:
a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]
print(np.matmul(a,b))
2/300:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    out = dotproduct(inten["1"],inten["2"])
    return out
2/301:
a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]

print(a*a)

print(np.matmul(a,b))
2/302:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    sqrtx = 0
    for i in x:
        sqrtx += i*i
    sqrty = 0
    for i in y:
        sqrty += i*i
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)
2/303:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    sqrtx = 0
    for i in x:
        sqrtx += i*i
    sqrty = 0
    for i in y:
        sqrty += i*i
    sqrtx = math.sqrt(sqrtx)
    print(sqrtx)
    sqrty = math.sqrt(sqrty)
    print(sqrty)
2/304:
a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]

print(dotProduct(a,b))
2/305:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
2/306:
a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]

print(dotProduct(a,b))
2/307: print(compareSpectra(s1,s2))
2/308:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    out = dotProduct(inten["1"],inten["2"])
    return out
2/309: print(compareSpectra(s1,s2))
2/310:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    if len(inten["1"]) == len(inten["2"]):
        out = dotProduct(inten["1"],inten["2"])
    elif len(inten["1"]) > len(inten["2"]):
        while len(inten["1"]) is not len(inten["2"]):
            inten["2"].append(0)
    elif len(inten["1"]) < len(inten["2"]):
        while len(inten["1"]) is not len(inten["2"]):
            inten["1"].append(0)
        
    return out
2/311: print(compareSpectra(s1,s2))
2/312:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11],[1,2,3,4,5,6,7,8,9,10,11])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/313: print(compareSpectra(s1,s2))
2/314:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11,12],[1,2,3,4,5,6,7,8,9,10,11,12])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/315: print(compareSpectra(s1,s2))
2/316:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11],[1,2,3,4,5,6,7,8,9,10,11,12])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/317: print(compareSpectra(s1,s2))
2/318:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    out = dotProduct(inten["1"],inten["2"])
    return out
2/319:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11],[1,2,3,4,5,6,7,8,9,10,11])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/320:
def compareSpectra(a,b):
    binnedSpectra = binSpectra(a,b)
    inten = {}
    counter = 1
    for i in binnedSpectra:
        inten[str(counter)] = i["intensity"]
        counter += 1
    
    out = dotProduct(inten["1"],inten["2"])
    return out
2/321: compareSpectra(s1,s2)
2/322:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11,12],[1,2,3,4,5,6,7,8,9,10,11])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/323:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
2/324: compareSpectra(s1,s2)
2/325:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10,11],[1,2,3,4,5,6,7,8,9,10,11])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/326: compareSpectra(s1,s2)
2/327:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5, 19.5, 20.5, 21.5, 22.5, 23.5, 24.5, 25.5, 26.5, 27.5, 28.5, 29.5, 30.5, 31.5, 32.5, 33.5, 34.5, 35.5, 36.5, 37.5, 38.5, 39.5, 40.5, 41.5, 42.5, 43.5, 44.5, 45.5, 46.5, 47.5, 48.5, 49.5, 50.5, 51.5, 52.5, 53.5, 54.5, 55.5, 56.5, 57.5, 58.5, 59.5, 60.5, 61.5, 62.5, 63.5, 64.5, 65.5, 66.5, 67.5, 68.5, 69.5, 70.5, 71.5, 72.5, 73.5, 74.5, 75.5, 76.5, 77.5, 78.5, 79.5, 80.5, 81.5, 82.5, 83.5, 84.5, 85.5, 86.5, 87.5, 88.5, 89.5, 90.5, 91.5, 92.5, 93.5, 94.5, 95.5, 96.5, 97.5, 98.5, 99.5, 100.5, 101.5, 102.5, 103.5, 104.5, 105.5, 106.5, 107.5, 108.5, 109.5, 110.5, 111.5, 112.5, 113.5, 114.5, 115.5, 116.5, 117.5, 118.5, 119.5, 120.5, 121.5, 122.5, 123.5, 124.5, 125.5, 126.5, 127.5, 128.5, 129.5, 130.5, 131.5, 132.5, 133.5, 134.5, 135.5],[13.0, 1.0, 7.0, 50.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
s2 = SampleFragmentsItem([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5, 11.5, 12.5, 13.5, 14.5, 15.5, 16.5, 17.5, 18.5, 19.5, 20.5, 21.5, 22.5, 23.5, 24.5, 25.5, 26.5, 27.5, 28.5, 29.5, 30.5, 31.5, 32.5, 33.5, 34.5, 35.5, 36.5, 37.5, 38.5, 39.5, 40.5, 41.5, 42.5, 43.5, 44.5, 45.5, 46.5, 47.5, 48.5, 49.5, 50.5, 51.5, 52.5, 53.5, 54.5, 55.5, 56.5, 57.5, 58.5, 59.5, 60.5, 61.5, 62.5, 63.5, 64.5, 65.5, 66.5, 67.5, 68.5, 69.5, 70.5, 71.5, 72.5, 73.5, 74.5, 75.5, 76.5, 77.5, 78.5, 79.5, 80.5, 81.5, 82.5, 83.5, 84.5, 85.5, 86.5, 87.5, 88.5, 89.5, 90.5, 91.5, 92.5, 93.5, 94.5, 95.5, 96.5, 97.5, 98.5, 99.5, 100.5, 101.5, 102.5, 103.5, 104.5, 105.5, 106.5, 107.5, 108.5, 109.5, 110.5, 111.5, 112.5, 113.5, 114.5, 115.5, 116.5, 117.5, 118.5, 119.5, 120.5, 121.5, 122.5, 123.5, 124.5, 125.5, 126.5, 127.5, 128.5, 129.5, 130.5, 131.5, 132.5, 133.5, 134.5, 135.5, 136.5],[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.099239, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.100512, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.141436, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 100.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.099737, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 41.389911, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
2/328: compareSpectra(s1,s2)
2/329: print(binSpectra(s1,s2))
2/330:
holder = s1.mz + s2.mz
print(holder)
2/331:
floor = math.floor(min(holder))
print(floor)
2/332:
ceiling = math.ceil(max(holder))
print(ceiling)
2/333:
breaks = list(range(floor,ceiling+1))
print(breaks)
2/334:
breaks = list(range(floor,ceiling+1))
print(breaks)
print(len(breaks))
2/335:
breaks = fixBreaks(breaks,[min(holder),max(holder)])
print(breaks)
print(len(breaks))
2/336: binSpectrum(s1,breaks)
2/337: binSpectrum(s2,breaks)
2/338: binSpectrum(s1,breaks)
2/339: compareSpectra(s1,s2)
2/340: print(binSpectra(s1,s2))
2/341:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
        
    print(len(iints))
    print(len(s))
    while len(iints) > len(s):
        iints.pop()
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/342: compareSpectra(s1,s2)
2/343:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
     
    print(len(iints))
    print(len(s))
    while len(iints) > len(s):
        iints.pop()
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/344: compareSpectra(s1,s2)
2/345:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
        
     
    print(len(iints))
    print(len(s))
    while len(iints) > len(s):
        iints.pop()
    
    
    print(len(iints))
    print(len(s))
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/346: compareSpectra(s1,s2)
2/347:
holder = s1.mz + s2.mz
floor = math.floor(min(holder))
ceiling = math.ceil(max(holder))


breaks = list(range(floor,ceiling+1))
breaks = fixBreaks(breaks,[min(holder),max(holder)])
2/348: breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
2/349:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
print(len(breaks1))
2/350:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
print(len(breaks2))
2/351:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
nbrks2 = len(breaks2)
print(len(breaks2))
print(len(nbrks1))
2/352:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
nbrks1 = len(breaks1)
print(len(breaks1))
print(nbrks1)
2/353:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
nbrks2 = len(breaks2)
print(len(breaks2))
print(nbrks1)
2/354:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
nbrks1 = len(breaks1)
print(len(breaks1))
print(nbrks1)

idx1 = findInterval(s1.mz,breaks1)
print(idx1)
2/355:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
nbrks1 = len(breaks1)
print(len(breaks1))
print(nbrks1)

idx1 = findInterval(s1.mz,breaks1)
print(len(idx1))
2/356:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
nbrks2 = len(breaks2)
print(len(breaks2))
print(nbrks1)

idx2 = findInterval(s2.mz,breaks2)
print(len(idx2))
2/357:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
nbrks1 = len(breaks1)
print(len(breaks1))
print(nbrks1)

idx1 = findInterval(s1.mz,breaks1)
print(len(idx1))
2/358:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
nbrks2 = len(breaks2)
print(len(breaks2))
print(nbrks1)

idx2 = findInterval(s2.mz,breaks2)
print(len(idx2))
2/359:
x = [1,2,3,4,5,6,7,8]
y = [1,3,4,5,6]
2/360: print(findInterval(x,y))
2/361: print(findInterval(x,y))
2/362: print(findInterval(x,y))
2/363: print(findInterval(x,y))
2/364: print(findInterval(x,y))
2/365: print(findInterval(x,y))
2/366: print(findInterval(x,y))
2/367: print(findInterval(x,y))
2/368: print(findInterval(x,y))
2/369: print(findInterval(x,y))
2/370:
print(findInterval(x,y))
print(x)
print(y)
2/371:
print(findInterval(x,y))
print(x)
print(y)
2/372:
print(findInterval(x,y))
print(x)
print(y)
2/373:
print(findInterval(x,y))
print(x)
print(y)
2/374:
print(findInterval(x,y))
print(x)
print(y)
2/375:
print(findInterval(x,y))
print(x)
print(y)
2/376:
print(findInterval(x,y))
print(x)
print(y)
2/377:
print(findInterval(x,y))
print(x)
print(y)
2/378:
print(findInterval(x,y))
print(x)
print(y)
2/379:
print(findInterval(x,y))
print(x)
print(y)
2/380:
def findInterval(x,vec):
    hold = vec
    hold.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    return out
2/381:
print(findInterval(x,y))
print(x)
print(y)
2/382:
print(findInterval(x,y))
print(x)
print(y)
2/383:
print(findInterval(x,y))
print(x)
print(y)
2/384:
print(findInterval(x,y))
print(x)
print(y)
2/385:
x = [1,2,3,4,5,6,7,8]
y = [1,3,4,5,6]
2/386:
print(findInterval(x,y))
print(x)
print(y)
2/387:
print(findInterval(x,y))
print(x)
print(y)
2/388:
print(findInterval(x,y))
print(x)
print(y)
2/389:
print(findInterval(x,y))
print(x)
print(y)
2/390:
print(findInterval(x,y))
print(x)
print(y)
2/391:
print(findInterval(x,y))
print(x)
print(y)
2/392:
print(findInterval(x,y))
print(x)
print(y)
2/393:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    vec.pop()
    return out
2/394:
print(findInterval(x,y))
print(x)
print(y)
2/395:
print(findInterval(x,y))
print(x)
print(y)
2/396:
print(findInterval(x,y))
print(x)
print(y)
2/397:
print(findInterval(x,y))
print(x)
print(y)
2/398:
print(findInterval(x,y))
print(x)
print(y)
2/399:
print(findInterval(x,y))
print(x)
print(y)
2/400: compareSpectra(s1,s2)
2/401: compareSpectra(s1,s2)
2/402: compareSpectra(s1,s2)
2/403: compareSpectra(s1,s2)
2/404: compareSpectra(s1,s2)
2/405: compareSpectra(s1,s2)
2/406: compareSpectra(s1,s2)
2/407: compareSpectra(s1,s2)
2/408: compareSpectra(s1,s2)
2/409: compareSpectra(s1,s2)
2/410: compareSpectra(s1,s2)
2/411: compareSpectra(s1,s2)
2/412: compareSpectra(s1,s2)
2/413: compareSpectra(s1,s2)
2/414: compareSpectra(s1,s2)
2/415: compareSpectra(s1,s2)
2/416: compareSpectra(s1,s2)
2/417:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    
    print(len(iints))
    print(len(s))
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/418: compareSpectra(s1,s2)
2/419: compareSpectra(s1,s2)
2/420: compareSpectra(s1,s2)
2/421: compareSpectra(s1,s2)
2/422: compareSpectra(s1,s2)
2/423: compareSpectra(s1,s2)
2/424: compareSpectra(s1,s2)
2/425:
x = [1,2,3,4,5,6,7,8]
y = [1,3,4,5,6]
2/426:
print(findInterval(x,y))
print(x)
print(y)
2/427:
print(findInterval(x,y))
print(x)
print(y)
2/428:
print(findInterval(x,y))
print(x)
print(y)
2/429:
print(findInterval(x,y))
print(x)
print(y)
2/430:
print(findInterval(x,y))
print(x)
print(y)
2/431:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
2/432: compareSpectra(s1,s2)
2/433:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
2/434: compareSpectra(s1,s2)
2/435: compareSpectra(s1,s1)
 3/1:
import math
import statistics
import numpy as np
 3/2:
def diff(x):
    counter = 0
    out = []
    while counter < len(x)-1:
        out.append(x[counter+1]-x[counter])
        counter += 1
    return out
 3/3:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
 3/4:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
 3/5:
def group_mz_values(x,mzd,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
 3/6:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
 3/7:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
 3/8:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
 3/9:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
3/10:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    vec.pop()
    return out
3/11:
x = [1,2,3,4,5,6,7,8]
y = [1,3,4,5,6]
3/12:
print(findInterval(x,y))
print(x)
print(y)
3/13:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
3/14:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
3/15:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
3/16: compareSpectra(s1,s1)
3/17:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
3/18:
brk = [1,2,3,4,5,6,7,8,9,10]
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
3/19:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
3/20:
#binValues(ints,mzs,brks)


breaks = fixBreaks(brks,[min(mzs),max(mzs)])
nbrks = len(breaks)
 idx = findInterval(mzs,breaks)
iints = []
for i in range(1,nbrks):
    iints.append(0)
s = split(ints,idx)
for j in s:
    s[j] = max(s[j])
for i in s:
    iints[i-1] = s[i]
        
        
if len(iints) > len(s):
    iints.pop()
    
out = {"x":[],"mid":[]}
x = []
mid = []
    
counter = 0
    
while counter < len(iints):
    try:
        x.append(iints[counter])
        mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
    except:
        pass
    counter += 1
    
out["x"] = x
out["mid"] = mid

print(out)
3/21:
holder = s1.mz + s2.mz
floor = math.floor(min(holder))
ceiling = math.ceil(max(holder))


breaks = list(range(floor,ceiling+1))
breaks = fixBreaks(breaks,[min(holder),max(holder)])
3/22:
breaks1 = fixBreaks(breaks,[min(s1.mz),max(s1.mz)])
nbrks1 = len(breaks1)
print(len(breaks1))
print(nbrks1)

idx1 = findInterval(s1.mz,breaks1)
print(len(idx1))
3/23:
breaks2 = fixBreaks(breaks,[min(s2.mz),max(s2.mz)])
nbrks2 = len(breaks2)
print(len(breaks2))
print(nbrks1)

idx2 = findInterval(s2.mz,breaks2)
print(len(idx2))
3/24:
a = [1,2,3,4,5,6,7,8,9,10]
b = [10,9,8,7,6,5,4,3,2,1]

print(dotProduct(a,b))
3/25:
#binValues(ints,mzs,brks)


breaks = fixBreaks(brks,[min(mzs),max(mzs)])
nbrks = len(breaks)
 idx = findInterval(mzs,breaks)
iints = []
for i in range(1,nbrks):
    iints.append(0)
s = split(ints,idx)
for j in s:
    s[j] = max(s[j])
for i in s:
    iints[i-1] = s[i]
        
        
if len(iints) > len(s):
    iints.pop()
    
out = {"x":[],"mid":[]}
x = []
mid = []
    
counter = 0
    
while counter < len(iints):
    try:
        x.append(iints[counter])
        mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
    except:
        pass
    counter += 1
    
out["x"] = x
out["mid"] = mid

print(out)
3/26:
#binValues(ints,mzs,brks)


breaks = fixBreaks(brks,[min(mzs),max(mzs)])
nbrks = len(breaks)
idx = findInterval(mzs,breaks)
iints = []
for i in range(1,nbrks):
    iints.append(0)
s = split(ints,idx)
for j in s:
    s[j] = max(s[j])
for i in s:
    iints[i-1] = s[i]
        
        
if len(iints) > len(s):
    iints.pop()
    
out = {"x":[],"mid":[]}
x = []
mid = []
    
counter = 0
    
while counter < len(iints):
    try:
        x.append(iints[counter])
        mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
    except:
        pass
    counter += 1
    
out["x"] = x
out["mid"] = mid

print(out)
3/27: compareSpectra(s1,s1)
3/28: compareSpectra(s1,s2)
3/29:
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
 4/1:
import math
import statistics
import numpy as np
 4/2:
def diff(x):
    counter = 0
    out = []
    while counter < len(x)-1:
        out.append(x[counter+1]-x[counter])
        counter += 1
    return out
 4/3:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
 4/4:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
 4/5:
def group_mz_values(x,mzd,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
 4/6:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
 4/7:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
 4/8:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
 4/9:
def fixBreaks(brks, rng):
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/10:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    vec.pop()
    return out
4/11:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))

    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/12:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
4/13:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/14:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
4/15:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
4/16:
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
4/17: compareSpectra(s1,s2)
4/18: s3 = SampleFragmentsItem([1112554137.0, 1113918698.0, 1114129270.0, 1114393468.0, 1116185819.0, 1116543835.0, 1116799607.0, 1116855833.0, 1118979558.0, 1119861277.0, 1120495270.0, 1120672823.0, 1122556477.0, 1122768331.0, 1122774070.0, 1122779529.0, 1122780082.0, 1122904754.0, 1122905553.0],[91.22666013982735, 91.21324327653628, 96.60166417765852, 96.83544523090082, 91.20883477531865, 91.24232922751713, 91.4061356661863, 92.33993071510126, 91.31492450519538, 91.22685185647981, 91.45532312602934, 91.48445709542689, 91.42935176736906, 92.8505531136098, 100.0, 92.99133516774872, 91.4691953609968, 91.76558993049018, 94.18016281092228])
4/19: compareSpectra(s3,s3)
4/20: s3 = SampleFragmentsItem([52.057224, 57.26261, 58.06588, 59.073715, 67.82198, 70.55343, 72.504814, 72.933784, 89.13652, 95.8635, 100.700485, 102.05511, 116.42625, 118.042564, 118.08635, 118.128, 118.13222, 119.08339, 119.089485],[0.028822, 0.028541999999999998, 4.094391, 5.343366, 0.028449999999999996, 0.029148999999999998, 0.033885, 0.08322, 0.030664, 0.028826000000000004, 0.035938, 0.037154, 0.034854, 0.12669, 100.0, 0.150194, 0.036517, 0.048888, 0.44734500000000005])
4/21: compareSpectra(s3,s3)
4/22: s3,ints
4/23: s3.intensity
4/24: len(s3.intensity)
4/25: len(s3.mz)
4/26: compareSpectra(s3,s3)
4/27: compareSpectra(s3,s3)
4/28:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
4/29:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        print(inten["1"])
        print(inten["2"])
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/30: compareSpectra(s3,s3)
4/31:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        print(len(inten["1"]))
        print(len(inten["2"]))
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/32: compareSpectra(s3,s3)
4/33: compareSpectra(s1,s1)
4/34: compareSpectra(s2,s2)
4/35: compareSpectra(s1,s2)
4/36: compareSpectra(s3,s3)
4/37:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        print(binnedSpectra)
        inten = {}
        print(inten)
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
    
        print(len(inten["1"]))
        print(len(inten["2"]))
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/38: compareSpectra(s3,s3)
4/39:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])

    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/40: compareSpectra(s3,s3)
4/41:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/42: compareSpectra(s3,s3)
4/43: compareSpectra(s3,s3)
4/44:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    print(breaks)
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/45: compareSpectra(s3,s3)
4/46: compareSpectra(s3,s3)
4/47: compareSpectra(s3,s3)
4/48: compareSpectra(s3,s3)
4/49: compareSpectra(s3,s3)
4/50: compareSpectra(s3,s3)
4/51: compareSpectra(s3,s3)
4/52: compareSpectra(s3,s3)
4/53: compareSpectra(s3,s3)
4/54: compareSpectra(s3,s3)
4/55: compareSpectra(s3,s3)
4/56: compareSpectra(s3,s3)
4/57: compareSpectra(s3,s3)
4/58:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    #print(breaks)
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/59: compareSpectra(s3,s3)
4/60:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/61:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    print(binSpectrum(x,breaks))
    print(binSpectrum(y,breaks))
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/62: compareSpectra(s3,s3)
4/63:
def binSpectra(x,y):
    holder = x.mz + y.mz
    print(holder)
    floor = math.floor(min(holder))
    print(floor)
    ceiling = math.ceil(max(holder))
    print(ceiling)
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    print(len(breaks))
    
    print(binSpectrum(x,breaks))
    print(binSpectrum(y,breaks))
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/64: compareSpectra(s3,s3)
4/65:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    print(len(breaks))
    
    print(binSpectrum(x,breaks))
    print(binSpectrum(y,breaks))
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/66: compareSpectra(s3,s3)
4/67:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    print(breaks)
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
4/68: compareSpectra(s3,s3)
4/69:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    print(breaks)
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
4/70: compareSpectra(s3,s3)
4/71:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    print(len(breaks))
    
    #print(binSpectrum(x,breaks))
    #print(binSpectrum(y,breaks))
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/72: compareSpectra(s3,s3)
4/73:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    print(len(breaks))
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
4/74: compareSpectra(s3,s3)
4/75:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    print(len(breaks))
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
4/76: compareSpectra(s3,s3)
4/77:
def fixBreaks(brks, rng):
    print(len(brks))
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/78: compareSpectra(s3,s3)
4/79:
def fixBreaks(brks, rng):
    print(len(brks))
    print(rng)
    if len(brks) <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/80: compareSpectra(s3,s3)
4/81:
def fixBreaks(brks, rng):
    print(len(brks))
    print(rng)
    if brks[len(brks)] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/82: compareSpectra(s3,s3)
4/83: compareSpectra(s1,s2)
4/84: compareSpectra(s3,s3)
4/85:
def fixBreaks(brks, rng):
    print(len(brks))
    print(rng)
    print(brks[len(brks)-1])
    if brks[len(brks)] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/86: compareSpectra(s3,s3)
4/87:
def fixBreaks(brks, rng):
    print(len(brks))
    print(rng)
    print(brks[len(brks)-1])
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/88: compareSpectra(s3,s3)
4/89:
def fixBreaks(brks, rng):
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/90:
def fixBreaks(brks, rng):
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/91: compareSpectra(s3,s3)
4/92:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/93: compareSpectra(s3,s3)
4/94:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/95:
def fixBreaks(brks, rng):
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/96: compareSpectra(s3,s3)
4/97: compareSpectra(s1,s2)
4/98:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/99: compareSpectra(s3,s3)
4/100:
import math
import statistics
import numpy as np
4/101:
def diff(x):
    counter = 0
    out = []
    while counter < len(x)-1:
        out.append(x[counter+1]-x[counter])
        counter += 1
    return out
4/102:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
4/103:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
4/104:
def group_mz_values(x,mzd,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
4/105:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
4/106:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
4/107:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
4/108:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    vec.pop()
    return out
4/109:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
4/110:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
4/111:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
4/112:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
4/113:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
4/114:
def fixBreaks(brks, rng):
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
4/115: compareSpectra(s3,s3)
4/116:
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
4/117: compareSpectra(s1,s2)
4/118: str("{:.6f}".format(compareSpectra(s1,s2)))
 5/1:
def cosine_similarity(DBsp,Msp,mzd=0,ppm=10):
    ## extract data from string
    DBsp = DBsp.split()
    Msp = Msp.split()
    mz1 = [0]*len(DBsp)
    int1 = [0]*len(DBsp)
    for k in range(0,len(mz1)):
        tmp = DBsp[k].split(':')
        mz1[k] = float(tmp[0])
        int1[k]=float(tmp[1])
    mz2 = [0]*len(Msp)
    int2 = [0]*len(Msp)
    for k in range(0,len(mz2)):
        tmp = Msp[k].split(':')
        mz2[k]=float(tmp[0])
        int2[k]=float(tmp[1])
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (numpy.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (numpy.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(numpy.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(numpy.array(mz_new),Int_new2)
    out = compareSpectra(sp1,sp2)
    return(out)
 5/2:
def cosine_similarity(DBsp,Msp,mzd=0,ppm=10):
    ## extract data from string
    DBsp = DBsp.split()
    Msp = Msp.split()
    mz1 = [0]*len(DBsp)
    int1 = [0]*len(DBsp)
    for k in range(0,len(mz1)):
        tmp = DBsp[k].split(':')
        mz1[k] = float(tmp[0])
        int1[k]=float(tmp[1])
    mz2 = [0]*len(Msp)
    int2 = [0]*len(Msp)
    for k in range(0,len(mz2)):
        tmp = Msp[k].split(':')
        mz2[k]=float(tmp[0])
        int2[k]=float(tmp[1])
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (numpy.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (numpy.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(numpy.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(numpy.array(mz_new),Int_new2)
    out = compareSpectra(sp1,sp2)
    return(out)
 6/1:
def group_mz_values(x,mzd = 0,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
 7/1:
import math
import statistics
import numpy as np
 7/2:
import math
import statistics
import numpy as np
 7/3:
def diff(x):
    counter = 0
    out = []
    while counter < len(x)-1:
        out.append(x[counter+1]-x[counter])
        counter += 1
    return out
 7/4:
def cosine_similarity(DBsp,Msp,mzd=0,ppm=10):
    ## extract data from string
    DBsp = DBsp.split()
    Msp = Msp.split()
    mz1 = [0]*len(DBsp)
    int1 = [0]*len(DBsp)
    for k in range(0,len(mz1)):
        tmp = DBsp[k].split(':')
        mz1[k] = float(tmp[0])
        int1[k]=float(tmp[1])
    mz2 = [0]*len(Msp)
    int2 = [0]*len(Msp)
    for k in range(0,len(mz2)):
        tmp = Msp[k].split(':')
        mz2[k]=float(tmp[0])
        int2[k]=float(tmp[1])
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (numpy.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (numpy.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(numpy.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(numpy.array(mz_new),Int_new2)
    out = compareSpectra(sp1,sp2)
    return(out)
 7/5:
class SampleFragmentsItem():

    def __init__(self,mz,intensity):
        self.mz = mz
        self.intensity = intensity
 7/6:
def cumsum(x):
    out = []
    sum = 0
    for i in x:
        sum += i
        out.append(sum)
    return out
 7/7:
def group_mz_values(x,mzd = 0,ppm = 0):
    mzdiff = diff(x)
    input_array = [0]
    counter = 0
    if ppm > 0:
        while counter < len(mzdiff):
            if mzdiff[counter] >= (mzd + x[-len(x)] * ppm / 1e6):
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
        return cumsum(input_array)
    else:
        while counter < len(mzdiff):
            if mzdiff[counter] >= mzd:
                input_array.append(1)
            else:
                input_array.append(0)
            counter += 1
        input_array.append(1)
 7/8:
def split(x,mapping):
    outDict = {}
    counter = 0
    while counter < len(x):
        if mapping[counter] in outDict:
            outDict[mapping[counter]].append(x[counter])
        else:
            outDict[mapping[counter]] = ([x[counter]])
        counter += 1

    return outDict
 7/9:
def lengths(x):
    out = []
    for key in x:
        out.append((key,len(x[key])))
    return out
7/10:
def ConsensusSpec(x,minProp,mzd = 0,ppm = 0):
    if len(x) == 1:
        return(x[0])

    allIntensities = []

    #normalise Data

    for i in x:
        highest = max(i.intensity)
        for j in i.intensity:
            j = (j/highest)*100


    for i in x:
        allIntensities += i.intensity

    mzList = []
    for sample in x:
        mzList.append(sample.mz)

    mzListLengths = []
    for mzs in mzList:
        mzListLengths.append(len(mzs))

    tracker = []
    counter = 1
    for i in mzList:
        for j in i:
            tracker.append((counter,j,allIntensities[counter-1]))
            counter += 1
    tracker.sort(key=lambda tup: tup[1])

    allMzOrder = []
    allMz = []
    intensities = []
    for i in tracker:
        allMzOrder.append(i[0])
        allMz.append(i[1])
        intensities.append(i[2])

    mz_groups = group_mz_values(allMz,mzd,ppm)

    mz_split = split(allMz,mz_groups)
    int_split = split(intensities,mz_groups)

    keep = []
    lens = lengths(mz_split)
    for i in mz_split:
        if len(mz_split[i]) >= len(x)*minProp:
            keep.append((i,True))
        else:
            keep.append((i,False))


    outMZS = []
    outINTS = []

    allCounter = 0
    while allCounter < len(mz_split):
        if keep[allCounter][1] == True:
            outMZS.append(sum(mz_split[allCounter])/len(mz_split[allCounter]))
            outINTS.append(sum(int_split[allCounter])/len(int_split[allCounter]))
        allCounter += 1

    #Finish normalise

    out = SampleFragmentsItem(outMZS,outINTS)

    return out
7/11:
def findInterval(x,vec):
    vec.append(max(x)+1)
    tracker = 0
    out = []
    for i in x:
        try:
            if i >= vec[tracker]:
                tracker += 1
                out.append(tracker)
            else:
                out.append(tracker)
        except:
            pass
    vec.pop()
    return out
7/12:
def compareSpectra(a,b):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
    
        binnedSpectra = binSpectra(a,b)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
7/13:
def dotProduct(x,y):
    mat = np.matmul(x,y)
    
    sqrtx = 0
    for i in x:
        sqrtx += i*i
        
    sqrty = 0
    for i in y:
        sqrty += i*i
        
    sqrtx = math.sqrt(sqrtx)
    sqrty = math.sqrt(sqrty)

    return mat/(sqrtx*sqrty)
7/14:
def binValues(ints,mzs,brks):
    breaks = fixBreaks(brks,[min(mzs),max(mzs)])
    nbrks = len(breaks)
    idx = findInterval(mzs,breaks)
    iints = []
    for i in range(1,nbrks):
        iints.append(0)
    s = split(ints,idx)
    for j in s:
        s[j] = max(s[j])
    for i in s:
        iints[i-1] = s[i]
    
    out = {"x":[],"mid":[]}
    x = []
    mid = []
    
    counter = 0
    
    while counter < len(iints):
        try:
            x.append(iints[counter])
            mid.append(statistics.mean([breaks[counter],breaks[counter+1]]))
        except:
            pass
        counter += 1
    
    out["x"] = x
    out["mid"] = mid
    
    return out
7/15:
def binSpectrum(x,breaks):
    bins = binValues(x.intensity, x.mz, breaks)
    obj = {}
    obj["mz"] = bins["mid"]
    obj["intensity"] = bins["x"]
    obj["tic"] = sum(obj["intensity"])
    obj["peaksCount"] = len(obj["mz"])
    
    return obj
7/16:
def binSpectra(x,y):
    holder = x.mz + y.mz
    floor = math.floor(min(holder))
    ceiling = math.ceil(max(holder))
    
    breaks = list(range(floor,ceiling+1))
    breaks = fixBreaks(breaks,[min(holder),max(holder)])
    
    return [binSpectrum(x,breaks),binSpectrum(y,breaks)]
7/17:
def fixBreaks(brks, rng):
    if brks[len(brks)-1] <= rng[1]:
        out = brks
        out.append(max([rng[1]+1e-6,brks[len(brks)-1] + statistics.mean(diff(brks))]))
        return out
    else:
        return brks
7/18: compareSpectra(s3,s3)
7/19:
s1 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
s2 = SampleFragmentsItem([1,2,3,4,5,6,7,8,9,10],[10,9,8,7,6,5,4,3,2,1])
7/20: compareSpectra(s1,s2)
7/21: s3 = SampleFragmentsItem([52.057224, 57.26261, 58.06588, 59.073715, 67.82198, 70.55343, 72.504814, 72.933784, 89.13652, 95.8635, 100.700485, 102.05511, 116.42625, 118.042564, 118.08635, 118.128, 118.13222, 119.08339, 119.089485],[0.028822, 0.028541999999999998, 4.094391, 5.343366, 0.028449999999999996, 0.029148999999999998, 0.033885, 0.08322, 0.030664, 0.028826000000000004, 0.035938, 0.037154, 0.034854, 0.12669, 100.0, 0.150194, 0.036517, 0.048888, 0.44734500000000005])
7/22: compareSpectra(s3,s3)
7/23: len(s3.mz)
7/24: str("{:.6f}".format(compareSpectra(s1,s2)))
7/25: print(cosine_similarity(s1,s2))
7/26: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/27:
import math
import statistics
import numpy as np
import pandas as pd
7/28: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/29:
import math
import statistics
import numpy as np
import pandas
7/30: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/31: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/32:
def cosine_similarity(DBsp,Msp,mzd=0,ppm=10):
    ## extract data from string
    DBsp = DBsp.split()
    Msp = Msp.split()
    mz1 = [0]*len(DBsp)
    int1 = [0]*len(DBsp)
    for k in range(0,len(mz1)):
        tmp = DBsp[k].split(':')
        mz1[k] = float(tmp[0])
        int1[k]=float(tmp[1])
    mz2 = [0]*len(Msp)
    int2 = [0]*len(Msp)
    for k in range(0,len(mz2)):
        tmp = Msp[k].split(':')
        mz2[k]=float(tmp[0])
        int2[k]=float(tmp[1])
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (np.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (np.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(numpy.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(numpy.array(mz_new),Int_new2)
    out = compareSpectra(sp1,sp2)
    return(out)
7/33: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/34:
def cosine_similarity(DBsp,Msp,mzd=0,ppm=10):
    ## extract data from string
    DBsp = DBsp.split()
    Msp = Msp.split()
    mz1 = [0]*len(DBsp)
    int1 = [0]*len(DBsp)
    for k in range(0,len(mz1)):
        tmp = DBsp[k].split(':')
        mz1[k] = float(tmp[0])
        int1[k]=float(tmp[1])
    mz2 = [0]*len(Msp)
    int2 = [0]*len(Msp)
    for k in range(0,len(mz2)):
        tmp = Msp[k].split(':')
        mz2[k]=float(tmp[0])
        int2[k]=float(tmp[1])
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (np.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (np.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(np.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(np.array(mz_new),Int_new2)
    out = compareSpectra(sp1,sp2)
    return(out)
7/35: print(cosine_similarity("1.6:39 6.5:95","1.6:39 6.5:95"))
7/36: print(cosine_similarity("50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557","50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557"))
7/37: print(cosine_similarity("50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557","50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557"))
7/38: print(cosine_similarity("50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557","50.7687486438034:1.00544415768482 51.487098263023:1.93731629983762 58.3869868362459:0.133224519218049 67.6303192648402:0.00770865955400873 70.1065424427614:100 70.0892825150668:0.0565958582926555 71.0525609721077:4.0318998067004 72.770658140497:0.591794138463199 78.118506054227:2.92974692676191 78.6137775199809:0.826573613263507 116.01298855109:2.01818702019834 116.005514995847:49.8019860081889 123.524875682917:0.612049846908557"))
7/39: cosine_similarity2(s3,s3)
7/40:
def cosine_similarity2(spec1,spec2,mzd=0,ppm=10):
    ## extract data from string
    mz1 = spec1.mz
    mz2 = spec2.mz
    
    ints1 = spec1.intensity
    ints2 = spec2.intensity
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (np.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (np.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(np.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(np.array(mz_new),Int_new2)
    return(sp1,sp2)
7/41: cosine_similarity2(s3,s3)
7/42:
def cosine_similarity2(spec1,spec2,mzd=0,ppm=10):
    ## extract data from string
    mz1 = spec1.mz
    mz2 = spec2.mz
    
    int1 = spec1.intensity
    int2 = spec2.intensity
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (np.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (np.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(np.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(np.array(mz_new),Int_new2)
    return(sp1,sp2)
7/43: cosine_similarity2(s3,s3)
7/44:
a = cosine_similarity2(s3,s3)
compareSpectra(a[0],a[1])
7/45:
a = cosine_similarity2(s1,s2)
compareSpectra(a[0],a[1])
7/46:
def compareSpectra(a,b,mzd=0,ppm=10):
    if (len(a.mz) == len(a.intensity)) and (len(b.mz) == len(b.intensity)):
        c,d = cosine_similarity2(a,b,mzd,ppm)
    
        binnedSpectra = binSpectra(c,d)
        inten = {}
        counter = 1
        for i in binnedSpectra:
            inten[str(counter)] = i["intensity"]
            counter += 1
        out = dotProduct(inten["1"],inten["2"])
        return out
    else:
        return "unmatched mz/intensity"
7/47:
def cosine_similarity2(spec1,spec2,mzd=0,ppm=10):
    ## extract data from string
    mz1 = spec1.mz
    mz2 = spec2.mz
    
    int1 = spec1.intensity
    int2 = spec2.intensity
    
    
    allMz = mz1+mz2
    allInts = int1+int2
    splab = ['A']*len(mz1)+['B']*len(mz2)
    spdf = pandas.DataFrame([allMz,allInts,splab]).transpose()
    spdf = spdf.sort_values(by=[0], ascending=True)

    mz_groups = group_mz_values(list(spdf[0]),mzd=mzd, ppm=ppm)
    mz_split = split(list(spdf[0]),mz_groups)
    lab_split = split(list(spdf[2]),mz_groups)
    int_split = split(list(spdf[1]),mz_groups)

    ks = mz_split.keys()

    mz_new = [0]*len(mz_split)
    Int_new1 = [0]*len(mz_split)
    Int_new2 = [0]*len(mz_split)

    counter = 0
    for k in ks:
        mz_new[counter] = sum(mz_split[k])/len(mz_split[k])
        intA = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='A']
        intB = [int_split[k][i] for i,val in enumerate(lab_split[k]) if val=='B']
        Int_new1[counter] = sum(intA)
        Int_new2[counter] = sum(intB)
        counter=counter+1  
    Int_new1 = (np.array(Int_new1)/max(Int_new1))*100
    Int_new2 = (np.array(Int_new2)/max(Int_new2))*100
    sp1 = SampleFragmentsItem(np.array(mz_new),Int_new1)
    sp2 = SampleFragmentsItem(np.array(mz_new),Int_new2)
    return(sp1,sp2)
7/48: compareSpectra(s1,s2)
7/49: compareSpectra(s3,s3)
 8/1:
if __name__ == "__main__":
    main()
 8/2:
if __name__ == "__main__":
    main()
 8/3: def main():
 8/4: import Logger as lg
 8/5:
if __name__ == "__main__":
    main()
 9/1:
if __name__ == '__main__':
    port = randint(1000,5000)
    reactor.listenUDP(port,Client("localhost",port))
    reactor.run()
 9/2: from random import randint
 9/3: from twisted.internet import reactor
 9/4: from twisted.internet.protocol import DatagramProtocol
 9/5:
class Client(DatagramProtocol):
    def __init__(self, host, port):
        if host == "localhost":
            host = "127.0.0.1"

        self.id = host, port
        self.address = None
        self.server = '127.0.0.1', 9999
        print("working on id: ", self.id)

    def startProtocol(self):
        self.transport.write("ready".encode('utf-8'), self.server)

    def datagramRecieved(self, datagram, addr):
        datagram = datagram.decode('utf-8')
        if addr == self.server:
            print("choose a client\n", datagram)
            self.address = input("write address:"), input("write port")
            reactor.callInThread(self.send_message)
        else:
            print(addr,":",datagram)

    def send_message(self):
        while True:
            self.transport.write(input(":::").encode('uft-8'), self.address)
 9/6:
if __name__ == '__main__':
    port = randint(1000,5000)
    reactor.listenUDP(port,Client("localhost",port))
    reactor.run()
10/1: from twisted.internet.protocol import DatagramProtocol
10/2: from twisted.internet import reactor
10/3:
class Server(DatagramProtocol):
    def __init__(self):
        self.Clients = set()

    def datagramRecieved(self, datagram, addr):
        datagram = datagram.decode('utf-8')
        if datagram == "ready":
            addresses = "\n".join([str(x) for x in self.clients])
            self.transport.write(addresses.encode('utf-8'), addr)
            self.clients.add(addr)
10/4:
if __name__ == '__main__':
    reactor.listenUDP(9999,Server())
    reactor.run()
11/1:
from twisted.internet.protocol import DatagramProtocol
from twisted.internet import reactor
from random import randint
11/2:
class Client(DatagramProtocol):
    def __init__(self, host, port):
        if host == "localhost":
            host = "127.0.0.1"

        self.id = host, port
        self.address = None
        self.server = '127.0.0.1', 9999
        print("working on id: ", self.id)

    def startProtocol(self):
        self.transport.write("ready".encode('utf-8'), self.server)

    def datagramRecieved(self, datagram, addr):
        datagram = datagram.decode('utf-8')
        if addr == self.server:
            print("choose a client\n", datagram)
            self.address = input("write address:"), input("write port")
            reactor.callInThread(self.send_message)
        else:
            print(addr,":",datagram)

    def send_message(self):
        while True:
            self.transport.write(input(":::").encode('uft-8'), self.address)
11/3:
if __name__ == '__main__':
    port = randint(1000,5000)
    reactor.listenUDP(port,Client("localhost",port))
    reactor.run()
13/1: print(1)
13/2: import socket
13/3: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
13/4: s.bind((socket.gethostname(),7000))
13/5: s.listen(10)
13/6: print(1)
13/7:
while True:
    clientsocket, address = s.accept()
    print(f"connection from {address} was made")
    clientsocket.send(bytes("hello","utf-8"))
12/1: import socket
12/2: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
12/3: s.connect((socket.gethostname(),7000))
12/4: print(socket.gethostname())
12/5: print(socket.gethostbyname(socket.gethostname()))
12/6: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
12/7: s.connect(("127.0.0.1",7022))
12/8: s.connect(("127.0.0.1",7022))
14/1: import socket
14/2: import select
15/1:         out = ET.Element('loot_tables')
15/2: from lxml import etree as ET
15/3:         out = ET.Element('loot_tables')
15/4:         outfile = ET.ElementTree(out)
15/5:         print(outfile)
15/6:         root = ET.Element('loot_tables')
15/7:         tree = ET.ElementTree(root)
15/8:         print(ET.tostring(root))
15/9:         root = ET.Element('loot_tables')
15/10:         tree = ET.ElementTree(root)
15/11:         loot_table=ET.Element('loot_table')
15/12:         print(ET.tostring(root))
15/13:         root.append(loot_table)
15/14:         print(ET.tostring(root))
15/15:         loot_table.append(5)
15/16:         loot_table.text = "hello"
15/17:         root.append(loot_table)
15/18:         root.append(loot_table)
15/19:         loot_table.text = "hello"
15/20:         loot_table.text = "hello"
15/21:         print(ET.tostring(root))
15/22:         print(ET.tostring(root))
15/23:         loot_table.text = "hell5"
15/24:         print(ET.tostring(root))
15/25:         loot_table.text = "hell"
15/26:         print(ET.tostring(root))
15/27:         root.append(loot_table)
15/28:         loot_table.text = "hell"
15/29:         loot_table.text = "hell"
15/30:         root.append(loot_table)
15/31:         loot_table.text = "6"
15/32:         print(ET.tostring(root))
15/33:         root = ET.Element('loot_tables')
15/34:         tree = ET.ElementTree(root)
15/35:
        for i in self.loot_tables:
            ET.Element(tree,'loot_table').text = self.loot_tables[0]
16/1:
if __name__ == "__main__":
    main()
15/36:         root = ET.Element('loot_tables')
15/37:         tree = ET.ElementTree(root)
15/38:         print(ET.tostring(root))
15/39:         tree.write(open(r'X:\dnd_2\tests\loot_tables2.xml','w'))
15/40:         ET.tostring(root)
15/41:         tree.write(open(r'X:\dnd_2\tests\loot_tables2.xml','w'))
15/42:         out = str(ET.tostring(root))
16/2:
if __name__ == "__main__":
    main()
18/1: importort pandas as pd
18/2: import pandas as pd
18/3: a = pd.load_csv("IPA_MS1.csv")
18/4: a = pd.read_csv("IPA_MS1.csv")
18/5: a
18/6:
import pandas as pd
import numpy as np
18/7: np.array_split(a,3)
18/8: b = np.array_split(a,3)
18/9: print(b[0])
18/10: b[0]
18/11: b[1]
18/12: b[2]
19/1: class Network_Viewer
20/1: train_set = [(0, 1),(2, 2),(4, 3),(9, 8),(3, 5)]
20/2: train_set = [(0, 1),(2, 2),(4, 3),(9, 8),(3, 5)]
20/3: print(train_set)
20/4:
train_set = [(0, 1),(2, 2),(4, 3),(9, 8),(3, 5)]
print(train_set)
21/1: import numpy as np
21/2: import numpy as np
21/3:
x = np.array([1,2,3,4,5])
y = np.array([4,2,5,2,5])
21/4:
x = np.array([1,2,3,4,5])
y = np.array([4,2,5,2,5])
21/5: x*y
21/6:
x = [1,2,3,4,5]
y = [4,2,5,2,5]
21/7: x*y
22/1: import pyautogui
22/2: import pyautogui
22/3: pyautogui.moveTo(100, 200)
22/4: import pyautogui
22/5: import pyautogui
22/6:
x = 5
y = 179
size_x = 1890
size_y = 893
22/7:
loc_x = self.x + ((self.size_x/100)*20)
loc_y = self.y + ((self.size_y/100)*16)
22/8:
loc_x = x + ((size_x/100)*20)
loc_y = y + ((size_y/100)*16)
22/9: pyautogui.moveTo(loc_x, loc_y)
22/10: pyautogui.moveTo(loc_x, loc_y)
22/11:
loc_x = x + ((size_x/100)*17)
loc_y = y + ((size_y/100)*30)
22/12: pyautogui.moveTo(loc_x, loc_y)
22/13:
loc_x = x + ((size_x/100)*17)
loc_y = y + ((size_y/100)*45)
22/14: pyautogui.moveTo(loc_x, loc_y)
22/15:
loc_x = x + ((size_x/100)*17)
loc_y = y + ((size_y/100)*51)
22/16: pyautogui.moveTo(loc_x, loc_y)
22/17:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*51)
22/18: pyautogui.moveTo(loc_x, loc_y)
22/19:
loc_x = x + ((size_x/100)*90)
loc_y = y + ((size_y/100)*51)
22/20: pyautogui.moveTo(loc_x, loc_y)
22/21:
loc_x = x + ((size_x/100)*85)
loc_y = y + ((size_y/100)*51)
22/22: pyautogui.moveTo(loc_x, loc_y)
22/23:
loc_x = x + ((size_x/100)*85)
loc_y = y + ((size_y/100)*96)
22/24: pyautogui.moveTo(loc_x, loc_y)
22/25:
loc_x = x + ((size_x/100)*85)
loc_y = y + ((size_y/100)*98)
22/26: pyautogui.moveTo(loc_x, loc_y)
22/27:
loc_x = x + ((size_x/100)*85)
loc_y = y + ((size_y/100)*97)
22/28: pyautogui.moveTo(loc_x, loc_y)
22/29:
loc_x = x + ((size_x/100)*20)
loc_y = y + ((size_y/100)*50)
22/30: pyautogui.moveTo(loc_x, loc_y)
22/31:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*20)
22/32: pyautogui.moveTo(loc_x, loc_y)
22/33:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*17)
22/34: pyautogui.moveTo(loc_x, loc_y)
22/35:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*90)
22/36: pyautogui.moveTo(loc_x, loc_y)
22/37:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*87)
22/38: pyautogui.moveTo(loc_x, loc_y)
22/39:
loc_x = x + ((size_x/100)*90)
loc_y = y + ((size_y/100)*17)
22/40: pyautogui.moveTo(loc_x, loc_y)
22/41:
loc_x = x + ((size_x/100)*90)
loc_y = y + ((size_y/100)*16)
22/42: pyautogui.moveTo(loc_x, loc_y)
22/43:
loc_x = x + ((size_x/100)*90)
loc_y = y + ((size_y/100)*14)
22/44: pyautogui.moveTo(loc_x, loc_y)
22/45:
loc_x = x + ((size_x/100)*50)
loc_y = y + ((size_y/100)*44)
22/46: pyautogui.moveTo(loc_x, loc_y)
23/1: print("hello")
23/2: import pickle
23/3:
import pickle
import pandas as pd
import numpy as np
23/4: IPA_data = pickle.load(open("example.pickle","rb"))
23/5:
import pickle
import pandas as pd
import numpy as np
23/6:
import pickle
import pandas as pd
import numpy as np
23/7: IPA_data = pickle.load(open("example.pickle","rb"))
23/8: IPA_data = pickle.load("example.pickle")
23/9:
file = open("example.pickle","r")
IPA_data = pickle.load()
23/10:
file = open("example.pickle","r")
IPA_data = pickle.load(file)
23/11:
file = open("ann.pickle","r")
IPA_data = pickle.load(file)
23/12:
file = open("ann.pickle","r")
IPA_data = pickle.loads(file)
23/13:
file = open("example.pickle","r")
IPA_data = pickle.loads(file)
23/14:
with open("example.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
23/15:
import pickle
#import pandas as pd
import numpy as np
23/16:
with open("example.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
23/17:
import pickle
import pandas as pd
import numpy as np
23/18:
with open("example.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
23/19: data = pd.read_pickle("example.pickle")
23/20:
with open("example.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
23/21: pd.__version__
23/22:
with open("ann.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
23/23:
with open("ann.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
24/1: pd.__version__
24/2:
import pickle
import pandas as pd
import numpy as np
24/3: pd.__version__
24/4:
with open("ann.pickle", 'rb') as handle:
    full_data = pickle.load(handle)
24/5: full_data[1]
24/6:
with open("example.pickle", 'rb') as handle:
    IPA_data = pickle.load(handle)
24/7:
import pickle
import pandas as pd
import numpy as np
import base64
24/8:
import pickle
import pandas as pd
import numpy as np
import base64
import gzip
24/9:
import pickle
import pandas as pd
import numpy as np
import gzip
24/10:
with gzip.open("allpeaks.peakml", "wb") as f:
    print(f)
24/11:
with gzip.open("allpeaks.peakml") as g:
    tree_data = g.read()
24/12:
with gzip.open("allpeaks.peakml") as g:
    tree_data = g.read()
    tree_data = tree_data.decode()
24/13: print(tree_data)
24/14: print(tree_data[1])
24/15:
with gzip.open('allpeaks.peakml', 'rb') as f, open('allpeaks_out.txt', 'w') as f_out:
    f_out.write(f.read())
24/16:
with gzip.open('allpeaks.peakml', 'rb') as f, open('allpeaks_out.txt', 'w') as f_out:
    f_out.write(f.read())
24/17:
with gzip.open("allpeaks.peakml") as g:
    tree_data = g.read()
    print(tree_data)
    #tree_data = tree_data.decode()
24/18:
with gzip.open("allpeaks.peakml","rb") as a:
    data = a.read()
    out = open("allpeaks_out.txt"","wb")
    out.write(data)
24/19:
with gzip.open("allpeaks.peakml","rb") as a:
    data = a.read()
    out = open("allpeaks_out.txt","wb")
    out.write(data)
24/20:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
24/21:
with gzip.open("allpeaks.peakml","rb") as a:
    data = a.read()
    out = open("allpeaks_out.txt","wb")
    out.write(data)
24/22:
with gzip.open("allpeaks.peakml","rb") as g:
    tree_data = g.read()
    print(tree_data)
    #tree_data = tree_data.decode()
24/23:
with gzip.open("allpeaks.peakml","rb") as g:
    tree_data = g.read()
    print(tree_data)
    #tree_data = tree_data.decode()
24/24:
with gzip.open("allpeaks.peakml","rb") as a:
    data = a.read()
    out = open("allpeaks_out.txt","wb")
    out.write(data)
24/25:
with gzip.open("edited.peakml","rb") as a:
    data = a.read()
    out = open("edited_out.txt","wb")
    out.write(data)
24/26:
with gzip.open("allpeaks.peakml","rb") as g:
    tree_data = g.read()
24/27:
with gzip.open("edited.peakml","rb") as g:
    PeakMl_Data = g.read()
24/28:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    return out
24/29: print(get_annotations(1))
24/30: print(IPA_data[1])
24/31:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = list(data["id"])
    
    
    
    
    
    
    return out
24/32: print(get_annotations(1))
24/33:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = '.'.join(list(data["id"]))
    
    
    
    
    
    
    return out
24/34: print(get_annotations(1))
24/35:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(list(data["id"]))
    
    
    
    
    
    
    return out
24/36: print(get_annotations(1))
24/37:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(list(data["id"]))
    out["IPA_name"] = ','.join(list(data["name"]))
    out["IPA_formula"] = ','.join(list(data["formula"]))
    out["IPA_adduct"] = ','.join(list(data["adduct"]))
    out["IPA_mz"] = ','.join(list(data["m/z"]))
    
    
    
    
    
    
    return out
24/38: print(get_annotations(1))
24/39:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    
    
    
    
    
    
    return out
24/40: print(get_annotations(1))
24/41: print(get_annotations(1))
24/42:
def get_annotations(id):
    out = {"IPA_id":"","IPA_name":"","IPA_formula":"","IPA_adduct":"","IPA_mz":"","IPA_charge":"","IPA_ppm":"","IPA_isotope_pattern_score":"","IPA_fragmentation_pattern_score":"","IPA_prior":"","IPA_post":"","IPA_post_Gibbs":"","IPA_post_chi_square_pval":""}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    
    
    
    
    
    return out
24/43: print(get_annotations(1))
24/44:
def get_annotations(id):
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    return out
24/45:
def get_annotations(id):
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    return out
24/46: print(get_annotations(1))
24/47: print(get_annotations(2))
24/48:
def get_annotations(id):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    return out
24/49: print(get_annotations(2))
24/50: print(get_annotations(1000))
24/51: print(get_annotations(100000))
24/52: print(get_annotations())
24/53: print(get_annotations(2))
24/54:
def input_string(data):
    out = ""
    for i in data:
        out += f"               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n"
    return out
24/55: print(input_string(get_annotations(2)))
24/56:
def input_string(data):
    out = ""
    for i in data:
        out += "                <annotation unit="">\n                  <label>" + i + "</label>\n                  <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n"
    return out
24/57: print(input_string(get_annotations(2)))
24/58:
def input_string(data):
    out = ""
    for i in data:
        out += "                <annotation unit="">\n                  <label>" + i + f"</label>\n                 <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n"
    return out
24/59: print(input_string(get_annotations(2)))
24/60:
def input_string(data):
    out = ""
    for i in data:
        out += "                <annotation unit="f">\n                 <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n"
    return out
24/61: print(input_string(get_annotations(2)))
24/62:
def input_string(data):
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
24/63: print(input_string(get_annotations(2)))
24/64: print(input_string(get_annotations(1)))
24/65: print(input_string(get_annotations(1000000)))
24/66:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
24/67: print(input_string(get_annotations(1000000)))
24/68: print(input_string(get_annotations(2)))
24/69: lines = PeakMl_Data.readlines()
24/70:
with gzip.open("edited.peakml","rb") as g:
    PeakMl_Data = g.read()
24/71: lines = PeakMl_Data.readlines()
24/72:
with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
24/73:
with gzip.open("edited.peakml","rb") as g:
    PeakMl_Data = g.read()
    out = open("temp_PeakMl_.txt","wb")
    out.write(PeakMl_Data)
24/74:
with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
24/75: print(lines[1])
24/76: print(lines[3])
24/77:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
    PeakMl_Data = g.read()
    out = open("temp_PeakMl_.txt","wb")
    out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>").replace("<patternid>"))
24/78:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
    PeakMl_Data = g.read()
    out = open("temp_PeakMl_.txt","wb")
    out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>").replace("<patternid>"))
        print(current_peak)
24/79:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>").replace("<patternid>"))
        print(current_peak)
24/80: add_IPA_to_PeakML("edited.peakml")
24/81:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>").replace("<patternid>"))
        if current_peak != None:
            print(current_peak)
24/82: add_IPA_to_PeakML("edited.peakml")
24/83:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>","").replace("<patternid>",""))
        if current_peak != None:
            print(current_peak)
24/84: add_IPA_to_PeakML("edited.peakml")
24/85:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = line.replace("           <patternid>","")
            current_peak = int(current_peak.replace("<patternid>",""))
            
        if current_peak != None:
            print(current_peak)
24/86: add_IPA_to_PeakML("edited.peakml")
24/87:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = line.replace("           <patternid>","").replace("</patternid>","")
        if current_peak != None:
            print(current_peak)
24/88:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>","").replace("</patternid>"))
        if current_peak != None:
            print(current_peak)
24/89: add_IPA_to_PeakML("edited.peakml")
24/90:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line.replace("           <patternid>","").replace("</patternid>",""))
        if current_peak != None:
            print(current_peak)
24/91: add_IPA_to_PeakML("edited.peakml")
24/92: #add_IPA_to_PeakML("edited.peakml")
24/93:
string = "                  <label>IPA_adduct</label>"
print(string[12:8])
24/94:
string = "                  <label>IPA_adduct</label>"
print(string[12:8])
24/95:
string = "                  <label>IPA_adduct</label>"
print(string[1:8])
24/96:
string = "                  <label>IPA_adduct</label>"
print(string[12:-8])
24/97:
string = "          <patternid>0</patternid>"
print(string[14:-12])
24/98:
string = "          <patternid>0</patternid>"
print(string.strip()[14:-12])
24/99: add_IPA_to_PeakML("edited.peakml")
24/100:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-12])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-8]
                
            if "            </annotations>" in line:
                line = input_string(get_annotations(current_peak)) + line
    
            
    with open("out.txt","w") as g:
        for line in lines:
            g.write(line)
24/101: add_IPA_to_PeakML("edited.peakml")
24/102:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                line = input_string(get_annotations(current_peak)) + line
    
            
    with open("out.txt","w") as g:
        for line in lines:
            g.write(line)
24/103: add_IPA_to_PeakML("edited.peakml")
24/104:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
         
    with open("out.txt","w") as g:
        for line in lines:
            g.write(line)
24/105: add_IPA_to_PeakML("edited.peakml")
24/106: add_IPA_to_PeakML("edited.peakml")
24/107: add_IPA_to_PeakML("allpeaks.peakml")
24/108:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
                print(line)
         
    with open("out.txt","w") as g:
        for line in lines:
            g.write(line)
24/109: add_IPA_to_PeakML("allpeaks.peakml")
24/110: print(IPA_data[0])
24/111: print(IPA_data[1])
24/112: print(IPA_data[605])
24/113:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                if current_peak == 605:
                    print(line)
                current_peak = 0
         
    with open("out_1.txt","w") as g:
        for line in lines:
            g.write(line)
24/114: add_IPA_to_PeakML("allpeaks.peakml")
24/115:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    current_peak = None
    
    checks = ['IPA_id','IPA_name','IPA_formula','IPA_adduct','IPA_mz','IPA_charge','IPA_ppm','IPA_isotope_pattern_score','IPA_fragmentation_pattern_score','IPA_prior','IPA_post','IPA_post_Gibbs','IPA_post_chi_square_pval']
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                if current_peak == 605:
                    #print(line)
                    if line in lines:
                        print("!!!!")
                current_peak = 0
        
    with open("out_1.txt","w") as g:
        for line in lines:
            g.write(line)
24/116: add_IPA_to_PeakML("allpeaks.peakml")
24/117:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_1.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
            g.write(line)
        
    with open("out_2.txt","w") as g:
        for line in lines:
            g.write(line)
24/118: add_IPA_to_PeakML("allpeaks.peakml")
24/119:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
            g.write(line)
24/120: add_IPA_to_PeakML("allpeaks.peakml")
24/121:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
            g.write(str(line))
24/122: add_IPA_to_PeakML("allpeaks.peakml")
24/123:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
            try:
                g.write(line)
            except:
                print(line)
24/124: add_IPA_to_PeakML("allpeaks.peakml")
24/125:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\n' in line:
                for l in line.split('/n'):
                    g.write(l)
            else:
                g.write(line)
24/126: add_IPA_to_PeakML("allpeaks.peakml")
24/127:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\n' in line:
                for l in line.split('/n'):
                    try:
                        g.write(l)
                    except:
                        print(l)
            else:
                g.write(line)
24/128: add_IPA_to_PeakML("allpeaks.peakml")
24/129:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\n' in line:
                print(line.split('/n'))
                for l in line.split('/n'):
                    try:
                        g.write(l)
                    except:
                        print(l)
            else:
                g.write(line)
24/130:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\n' in line:
                print(line.split('/n'))
                for l in line.split('/n'):
                    try:
                        g.write(l)
                    except:
                        print(l)
            else:
                g.write(line)
24/131: add_IPA_to_PeakML("allpeaks.peakml")
24/132:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    

            g.write(line)
24/133: add_IPA_to_PeakML("allpeaks.peakml")
24/134:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                print(line)
            g.write(line)
24/135: add_IPA_to_PeakML("allpeaks.peakml")
24/136:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                g.write(line).replace("",'\u03b1')
            else:
                g.write(line)
24/137: add_IPA_to_PeakML("allpeaks.peakml")
24/138:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                print(line)
                g.write(line).replace("",'a')
            else:
                g.write(line)
24/139: add_IPA_to_PeakML("allpeaks.peakml")
24/140:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                print(line)
                g.write(line.replace("",'a'))
            else:
                g.write(line)
24/141: add_IPA_to_PeakML("allpeaks.peakml")
24/142:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","w") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                #print(line)
                g.write(line.replace("",'a'))
            else:
                g.write(line)
24/143: add_IPA_to_PeakML("allpeaks.peakml")
24/144:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    with open("out_2.txt","wb") as g:
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0
                  
                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]
                
                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = 0
                    
            if '\u03b1' in line:
                #print(line)
                g.write(line.replace("",'a'))
            else:
                g.write(line)
24/145: add_IPA_to_PeakML("allpeaks.peakml")
24/146:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","wb") as gb:
        for line in new_lines:
            g.write(line)
24/147: add_IPA_to_PeakML("allpeaks.peakml")
24/148:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","wb") as g:
        for line in new_lines:
            g.write(line)
24/149: add_IPA_to_PeakML("allpeaks.peakml")
24/150:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","w") as g:
        for line in new_lines:
            g.write(line)
24/151:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","w") as g:
        for line in new_lines:
            g.write(line)
24/152: add_IPA_to_PeakML("allpeaks.peakml")
24/153:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","w",encoding="utf-32") as g:
        for line in new_lines:
            g.write(line)
24/154: add_IPA_to_PeakML("allpeaks.peakml")
24/155:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_2.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
24/156: add_IPA_to_PeakML("allpeaks.peakml")
24/157:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_3.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
24/158: add_IPA_to_PeakML("allpeaks.peakml")
24/159:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
            
    with open("out_IPA_TEMP.txt", 'rb') as f_in:
        with gzip.open(file, 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)
24/160:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
            
    with open("out_IPA_TEMP.txt", 'rb') as f_in:
        with gzip.open(file, 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)
    os.remove("out_IPA_TEMP.txt")
    os.remove("temp_PeakMl_.txt")
24/161: add_IPA_to_PeakML("allpeaks.peakml")
24/162:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
            
    with open("out_IPA_TEMP.txt", 'rb') as f_in:
        with gzip.open(file, 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)
    #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
    #os.remove("temp_PeakMl_.txt")
24/163: add_IPA_to_PeakML("allpeaks.peakml")
24/164: add_IPA_to_PeakML("allpeaks_test.peakml")
24/165:
def add_IPA_to_PeakML(file):
    with gzip.open(file,"rb") as g:
        PeakMl_Data = g.read()
        out = open("temp_PeakMl_.txt","wb")
        out.write(PeakMl_Data)
    
    with open("temp_PeakMl_.txt","r") as g:
        lines = g.readlines()
    
    
    new_lines = []
    current_peak = None
    IPA_data_already_exists = 0
    for line in lines:
        if "            <patternid>" in line:
            current_peak = int(line[14:-13])
        if current_peak != None:
            if IPA_data_already_exists != 0:
                line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                IPA_data_already_exists = 0
                  
            if "IPA" in line and "<label>" in line:
                IPA_data_already_exists = line[12:-9]
                
            if "            </annotations>" in line:
                peak_data = input_string(get_annotations(current_peak))
                if peak_data != None:
                    line = peak_data + line
                current_peak = 0
        new_lines.append(line)
                    
    with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
        for line in new_lines:
            g.write(line)
            
    with open("out_IPA_TEMP.txt", 'rb') as f_in:
        with gzip.open("temp.peakml", 'wb') as f_out:
            shutil.copyfileobj(f_in, f_out)
    #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
    #os.remove("temp_PeakMl_.txt")
24/166: add_IPA_to_PeakML("allpeaks_test.peakml")
24/167: add_IPA_to_PeakML("allpeaks.peakml")
26/1:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
26/2:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
26/3:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
26/4: print(IPA_data_[605])
26/5: print(get_annotations(2))
26/6:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    return out
26/7: print(get_annotations(2))
26/8: print(get_annotations(2,IPA_data_))
26/9: print(IPA_data_[2])
26/10:
change = " Eta"
print(f'"{change[0]}:[{change[-2]}]"')
26/11:
change = " Eta"
print(f'"{change[0]}:[{change[-2:]}]"')
26/12:
change = " Eta"
print(f'"{change[0]}:[{change[2:]}]"')
26/13:
change = " Eta"
print(f'"{change[0]}":"[{change[2:]}]"')
26/14:
change = " Eta"
print(f',"{change[0]}":"[{change[2:]}]"')
26/15:
change = " Theta"
print(f',"{change[0]}":"[{change[2:]}]"')
26/16:
change = " Iota"
print(f',"{change[0]}":"[{change[2:]}]"')
26/17:
change = " Kappa"
print(f',"{change[0]}":"[{change[2:]}]"')
26/18:
change = " Lambda"
print(f',"{change[0]}":"[{change[2:]}]"')
26/19:
change = " Mu"
print(f',"{change[0]}":"[{change[2:]}]"')
26/20:
change = " Nu"
print(f',"{change[0]}":"[{change[2:]}]"')
26/21:
if "v" == "":
    print(1)
26/22:
if "v" == "":
    print(1)
26/23:
if "v" == "":
    print(1)
26/24:
if "v" == "":
    print(1)
26/25:
if "v" == "":
    print(1)
26/26:
if "v" == "":
    print(1)
26/27:
if "v" == "":
    print(1)
26/28:
if "v" == "":
    print(1)
26/29:
if "v" == "":
    print(1)
26/30:
if "v" == "":
    print(1)
26/31: print(chr())
26/32: print(chr(""))
26/33:
if "v" == "":
    print(1)
26/34: print(int(a))
26/35: print(int("a"))
26/36: print(ord("a"))
26/37: print(ord("v"))
26/38: print(ord(""))
26/39:
change = " Xi"
print(f',"{change[0]}":"[{change[2:]}]"')
26/40:
change = " Omicron"
print(f',"{change[0]}":"[{change[2:]}]"')
26/41:
change = " Pi"
print(f',"{change[0]}":"[{change[2:]}]"')
26/42:
change = " Rho"
print(f',"{change[0]}":"[{change[2:]}]"')
26/43:
change = " Sigma"
print(f',"{change[0]}":"[{change[2:]}]"')
26/44:
change = " Tau"
print(f',"{change[0]}":"[{change[2:]}]"')
26/45:
change = " Upsilon"
print(f',"{change[0]}":"[{change[2:]}]"')
26/46:
change = " Phi"
print(f',"{change[0]}":"[{change[2:]}]"')
26/47:
change = " Chi"
print(f',"{change[0]}":"[{change[2:]}]"')
26/48:
change = " Psi"
print(f',"{change[0]}":"[{change[2:]}]"')
26/49:
change = " Omega"
print(f',"{change[0]}":"[{change[2:]}]"')
26/50:
a = "abbbs"
print(replace("b","c"))
26/51:
a = "abbbs"
print(a.replace("b","c"))
26/52:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
26/53:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
26/54: print(IPA_data_[2])
26/55:
with gzip.open("edited.peakml","rb") as g:
    PeakMl_Data = g.read()
    out = open("temp_PeakMl_.txt","wb")
    out.write(PeakMl_Data)
26/56:
with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
26/57: print(lines[3])
26/58:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    return out
26/59: print(get_annotations(2,IPA_data_))
26/60:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
26/61: print(input_string(get_annotations(2)))
26/62: print(input_string(get_annotations(2,IPA_data_)))
26/63:
string = "          <patternid>0</patternid>"
print(string[14:-12])
26/64:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()


        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line)

        with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/65: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/66:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()


        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line)

        with open("out_IPA_TEMP.txt","w",encoding="utf-8") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/67: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/68:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
26/69: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/70:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()


        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line)

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/71: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/72:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()

        checks = {"":"[Alpha]","":"[Beta]","":"[Gamma]","":"[Delta]","":"[Epsilon]","":"[Zeta]","":"[Eta]","":"[Theta]","":"[Iota]","":"[Kappa]","":"[Lambda]","":"[Mu]","":"[Nu]","":"[Xi]","":"[Omicron]","":"[Pi]","":"[Rho]","":"[Sigma]","":"[Tau]","":"[Upsilon]","":"[Phi]","":"[Chi]","":"[Psi]","":"[Omega]"}
            
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    for i in checks:
                        line = line.replace(i,checks[i])
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
                for i in checks:
                    line = line.replace(i,checks[i])
            new_lines.append(line)
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/73: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/74:
if "P" == "":
    print(1)
26/75:
if "P" == "":
    print(1)
26/76:
if "" == "N":
    print(1)
26/77:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()

        checks = {"":"[Alpha]","":"[Beta]","":"[Gamma]","":"[Delta]","":"[Epsilon]","":"[Zeta]","":"[Eta]","":"[Theta]","":"[Iota]","":"[Kappa]","":"[Lambda]","":"[Mu]","":"[Nu]","":"[Xi]","":"[Omicron]","":"[Pi]","":"[Rho]","":"[Sigma]","":"[Tau]","":"[Upsilon]","":"[Phi]","":"[Chi]","":"[Psi]","":"[Omega]","":"[Alpha]","":"[Beta]","":"[Gamma]","":"[Delta]","":"[Epsilon]","":"[Zeta]","":"[Eta]","":"[Theta]","":"[Iota]","":"[Kappa]","":"[Lambda]","":"[Mu]","":"[Nu]","":"[Xi]","":"[Omicron]","":"[Pi]","":"[Rho]","":"[Sigma]","":"[Sigma]","":"[Tau]","":"[Upsilon]","":"[Phi]","":"[Chi]","":"[Psi]","":"[Omega]"}
            
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    for i in checks:
                        line = line.replace(i,checks[i])
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
                for i in checks:
                    line = line.replace(i,checks[i])
            new_lines.append(line)
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/78: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/79:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()

        checks = {"":"[Alpha]","":"[Beta]","":"[Gamma]","":"[Delta]","":"[Epsilon]","":"[Zeta]","":"[Eta]","":"[Theta]","":"[Iota]","":"[Kappa]","":"[Lambda]","":"[Mu]","":"[Nu]","":"[Xi]","":"[Omicron]","":"[Pi]","":"[Rho]","":"[Sigma]","":"[Tau]","":"[Upsilon]","":"[Phi]","":"[Chi]","":"[Psi]","":"[Omega]","":"[Alpha]","":"[Beta]","":"[Gamma]","":"[Delta]","":"[Epsilon]","":"[Zeta]","":"[Eta]","":"[Theta]","":"[Iota]","":"[Kappa]","":"[Lambda]","":"[Mu]","":"[Nu]","":"[Xi]","":"[Omicron]","":"[Pi]","":"[Rho]","":"[Sigma]","":"[Sigma]","":"[Tau]","":"[Upsilon]","":"[Phi]","":"[Chi]","":"[Psi]","":"[Omega]","":"^6"}                  
            
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    for i in checks:
                        line = line.replace(i,checks[i])
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
                for i in checks:
                    line = line.replace(i,checks[i])
            new_lines.append(line)
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/80: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/81:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
26/82:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/83: print(get_annotations(7,IPA_data_))
26/84: print(IPA_data_[7])
26/85:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/86: print(get_annotations(7,IPA_data_))
26/87: print(f"[{unicodedata.name("a")}]")
26/88: print(f'[{unicodedata.name("a")}]')
26/89:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/90: print(get_annotations(7,IPA_data_))
26/91:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            print(new_string)
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/92: print(get_annotations(7,IPA_data_))
26/93:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
            print(i)
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/94: print(get_annotations(7,IPA_data_))
26/95:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    print(out["IPA_name"])
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/96: print(get_annotations(7,IPA_data_))
26/97:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    print(out["IPA_name"])
    
    
    
    
    return out
26/98: print(get_annotations(7,IPA_data_))
26/99:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
    new_string = ""
    print(out["IPA_name"])
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/100: get_annotations(7,IPA_data_)
26/101:
a = "a"
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/102:
check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
a = "a"
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/103:
check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
a = "a"
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/104:
check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
a = "a"
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/105:
check = ["abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"]
a = 'a'
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/106:
check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"
a = 'a'
if a not in check:
    print(f'[{unicodedata.name(a)}]')
26/107:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"
    new_string = ""
    print(out["IPA_name"])
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            print(f"[{unicodedata.name(i)}]")
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/108: print(get_annotations(7,IPA_data_))
26/109:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,"
    new_string = ""
    print(out["IPA_name"])
    for i in out["IPA_name"]:
        print(new_string)
        if i in check:
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    
    
    
    return out
26/110: print(get_annotations(7,IPA_data_))
26/111: print(get_annotations(7,IPA_data_)["IPA_name"])
26/112: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/113: print(get_annotations(7,IPA_data_)["IPA_name"])
26/114: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/115:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/116: print(get_annotations(7,IPA_data_)["IPA_name"])
26/117:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/118: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/119: \u2032
26/120: chr(\u2032)
26/121: chr("\u2032")
26/122: chr('\u2032')
26/123: '\u2032'
26/124:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            if i == '\u2032':
                new_string += "[Prime]"
            else:
                new_string += f"[{unicodedata.name(i)}]"
    return out
26/125: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/126: '\u2032'
26/127:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            if i == '':
                new_string += "[Prime]"
            else:
                new_string += f"[{unicodedata.name(i)}]"
    return out
26/128: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/129:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                new_string += f"[{unicodedata.name(i)}]"
            except:
                new_string += "[Prime]"
    return out
26/130: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/131: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/132:
    def add_IPA_to_PeakML(file,IPA_Data):
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        for line in lines:
            if "            <patternid>" in line:
                current_peak = int(line[14:-13])
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
26/133: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/134:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/135: print(get_annotations(7,IPA_data_)["IPA_name"])
26/136: print(unicodedata.name(""))
26/137: print(get_annotations(7,IPA_data_)["IPA_name"])
26/138:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            print(i)
            new_string += i
        else:
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/139: print(unicodedata.name(""))
26/140: print(get_annotations(7,IPA_data_)["IPA_name"])
26/141:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i)
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/142: print(get_annotations(7,IPA_data_)["IPA_name"])
26/143:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i)
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/144: print(get_annotations(7,IPA_data_)["IPA_name"])
26/145:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i)
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/146:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i)
            new_string += f"[{unicodedata.name(i)}]"
    return out
26/147: print(get_annotations(7,IPA_data_)["IPA_name"])
26/148:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i)
            new_string += f"[{unicodedata.name(i)}]"
            print(new_string)
    return out
26/149: print(get_annotations(7,IPA_data_)["IPA_name"])
26/150:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i,unicodedata.name(i))
            new_string += f"[{unicodedata.name(i)}]"
            #print(new_string)
    return out
26/151: print(get_annotations(7,IPA_data_)["IPA_name"])
26/152:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i,unicodedata.name(i))
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
            print(new_string)
    return out
26/153: print(get_annotations(7,IPA_data_)["IPA_name"])
26/154: print(unicodedata.name(""))
26/155:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i,unicodedata.name(i))
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
            print(new_string)
    return out
26/156: print(get_annotations(7,IPA_data_)["IPA_name"])
26/157:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+''"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i,unicodedata.name(i))
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
            print(new_string)
    return out
26/158:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            print(i,unicodedata.name(i))
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
            print(new_string)
    return out
26/159: print(get_annotations(7,IPA_data_)["IPA_name"])
26/160: print(get_annotations(7,IPA_data_)["IPA_name"])
26/161:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    return out
26/162: print(get_annotations(7,IPA_data_)["IPA_name"])
26/163:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
26/164:     print(get_annotations(7,IPA_data_)["IPA_name"])
26/165: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
26/166:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ','.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ','.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ','.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ','.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ','.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ','.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ','.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ','.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ','.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ','.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ','.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ','.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ','.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
26/167: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/1:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
27/2:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
27/3: print(IPA_data_[7])
27/4: print(IPA_data_[0])
27/5: print(IPA_data_[1])
27/6:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
27/7:
string = "                  <label>id</label>"
print(string[14:-12])
27/8:
string = "                  <label>id</label>"
print(string[10:-12])
27/9:
string = "                  <label>id</label>"
print(string[10:-7])
27/10:
string = "                  <value>1</value>"
print(string[10:-7])
27/11:
string = "                  <value>1</value>"
print(string[12:-8])
27/12:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
import time
27/13:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
27/14: print(IPA_data_[1])
27/15:
with gzip.open("edited.peakml","rb") as g:
    PeakMl_Data = g.read()
    out = open("temp_PeakMl_.txt","wb")
    out.write(PeakMl_Data)
27/16:
with open("temp_PeakMl_.txt","r") as g:
    lines = g.readlines()
27/17: print(lines[3])
27/18: def Add_IPA_data_to_PeakMl(peakml_input,IPA_data,peakml_output):
27/19:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
27/20: print(unicodedata.name(""))
27/21:     print(get_annotations(7,IPA_data_)["IPA_name"])
27/22:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
27/23: print(input_string(get_annotations(2,IPA_data_)))
27/24:
string = "                  <value>1</value>"
print(string[12:-8])
27/25:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if "                    <label>id</label>" in line and looking_at_peak:
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{timer - time.perf_counter():0.4f} Seconds")
27/26: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/27:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-8]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                new_lines.append(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/28: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/29:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if "                    <label>id</label>" in line and looking_at_peak:
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/30:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-8]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                new_lines.append(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/31:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if "                    <label>id</label>" in line and looking_at_peak:
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/32: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/33: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/34:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-8]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                new_lines.append(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/35: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/36: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/37:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-8]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/38: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/39:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if "                    <label>id</label>" in line and looking_at_peak:
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/40: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/41:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if "                    <label>id</label>" in line and looking_at_peak:
                print(1)
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/42: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/43:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if ("                   <label>id</label>" in line) and looking_at_peak:
                print(1)
                current_peak = line[12:-8]
                looking_at_peak = 0
                
            if current_peak != None:
                print(2)
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    print(3)
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/44: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/45:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if "            <patternid>" in line:
                looking_at_peak = 1
                
            if ("                   <label>id</label>" in line) and looking_at_peak:
                print(1)
                current_peak = line[12:-9]
                looking_at_peak = 0
                
            if current_peak != None:
                print(2)
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    print(3)
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/46:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-9]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/47:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "            <patternid>" in line:
                    looking_at_peak = 1

                if "                    <label>id</label>" in line and looking_at_peak:
                    current_peak = line[12:-9]
                    looking_at_peak = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/48: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/49:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "                    <label>id</label>" in line:
                    looking_for_id = 1
                
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/50: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/51:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if "                    <label>id</label>" in line:
                    looking_for_id = 1
                
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/52: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/53:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/54: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/55:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    print(current_peak)
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/56:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    print(current_peak)
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(1)
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/57: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/58:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/59: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/60:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if looking_for_id:
                current_peak = line[12:-9]
                looking_for_id = 0
                print(current_peak)
                    
            if "                    <label>id</label>" in line:
                looking_for_id = 1

            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    print("---")
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/61:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if looking_for_id:
                current_peak = line[12:-9]
                looking_for_id = 0
                print(current_peak)
                    
            if "                    <label>id</label>" in line:
                looking_for_id = 1

            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    print("---")
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/62: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/63:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/64:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/65: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/66:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    print(out)
    return out
27/67:     print(get_annotations(7,IPA_data_)["IPA_name"])
27/68:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
27/69:     print(get_annotations(1,IPA_data_)["IPA_name"])
27/70:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/71: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/72:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/73: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/74:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/75:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/76: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/77:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/78: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/79:
def get_annotations(id,IPA_data):
    if int(id) not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
27/80: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/81: #print(input_string(get_annotations(2,IPA_data_)))
27/82: print(input_string(get_annotations(2,IPA_data_)))
27/83: print(input_string(get_annotations(1,IPA_data_)))
27/84:
def get_annotations(id,IPA_data):
    if id not in IPA_data:    # needs change here to ipa dictionary loaction
        return None
    out = {}
    data = IPA_data[id]   # needs change here to ipa dictionary loaction
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            sc = unicodedata.name(i)
            new_string += f"[{sc}]"
    out["IPA_name"] = new_string
    return out
27/85:     print(get_annotations(1,IPA_data_)["IPA_name"])
27/86:     print(get_annotations(1,IPA_data_))
27/87:     print(get_annotations(1,IPA_data_)["IPA_name"])
27/88:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
27/89:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
27/90: print(input_string(get_annotations(2,IPA_data_)))
27/91:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/92: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/93:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
27/94:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
print(peak_data)
27/95:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/96:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
#print(peak_data)
27/97: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/98:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data)
                        print("---")
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/99: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/100: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/101:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
#print(peak_data)
27/102:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
print(peak_data)
27/103:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
#print(peak_data)
27/104:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data[1])
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/105: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/106:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data[1])
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/107: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/108:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
print(peak_data)
27/109:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    print(current_peak)
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data[1])
                        print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/110:
IPA_Data = IPA_data_
current_peak = 1
peak_data = input_string(get_annotations(current_peak,IPA_Data))
#print(peak_data)
27/111: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/112:
IPA_Data = IPA_data_
current_peak = 1
peak_data = get_annotations(current_peak,IPA_Data)
print(peak_data)
27/113:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data[1])
                        print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/114:
IPA_Data = IPA_data_
current_peak = 1
peak_data = get_annotations(current_peak,IPA_Data)
#print(peak_data)
27/115:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        print(IPA_Data[1])
                        print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            print(peak_data + line)
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/116:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/117: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/118:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_data_))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/119: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/120:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(1,IPA_data_))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/121: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/122:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        if current_peak == 1:
                            print(1)
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_data))
                        #print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/123: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/124:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    str(current_peak) = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_data))
                        #print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/125: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/126:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    str(current_peak) = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        #print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/127: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/128:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    str(current_peak) = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/129: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/130:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    str(current_peak) = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/131: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/132:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    str(current_peak) = line[12:-9]
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/133: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/134:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = str(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/135: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/136:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        print(current_peak)
                        #print(IPA_Data[1])
                        #print(get_annotations(current_peak,IPA_Data))
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        print(peak_data)
                        if peak_data != None:
                            #print(peak_data + line)
                            line = peak_data + line
                        #print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/137: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/138:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/139:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/140: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/141:
def get_annotations(id,IPA_data):
    if id not in IPA_data:   
        return None
    out = {}
    data = IPA_data[id]  
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                sc = unicodedata.name(i)
                new_string += f"[{sc}]"
            except:
                print(f"{i} does not exist in unicode")
    out["IPA_name"] = new_string
    return out
27/142: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/143:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        new_lines = []
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        for line in lines:
            if looking_for_id:
                current_peak = int(line[12:-9])
                looking_for_id = 0
                    
            if "                    <label>id</label>" in line:
                looking_for_id = 1

            if current_peak != None:
                if IPA_data_already_exists != 0:
                    line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                    IPA_data_already_exists = 0

                if "IPA" in line and "<label>" in line:
                    IPA_data_already_exists = line[12:-9]

                if "            </annotations>" in line:
                    peak_data = input_string(get_annotations(current_peak,IPA_Data))
                    if peak_data != None:
                        line = peak_data + line
                    current_peak = None
            new_lines.append(line.replace('',"[Prime]"))
            

        with open("out_IPA_TEMP.txt","w") as g:
            for line in new_lines:
                g.write(line)

        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/144: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/145:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            print(1)
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/146: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/147: print(input_string(get_annotations(7,IPA_data_)))
27/148:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/149: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/150:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        print(line)
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp2.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/151: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/152:
    def add_IPA_to_PeakML(file,IPA_Data):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open("temp2.peakml", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/153: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test50.peakml")
27/154:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/155: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test50.peakml")
27/156:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
import time
import math
27/157:
def progress(p,t):
    per = 100 * (p/float(t))
    bar = '#' * int(per) + '-'*(100-int(per))
    print(f"\r|{bar}| {per:2f}%", end="\r")
27/158:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        counter = 0
        total_l = len(lines)
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                progress(counter,total_l)
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/159: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_)
27/160: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test50.peakml")
27/161:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            



        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/162:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
27/163: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test50.peakml")
27/164:
def get_annotations(id,IPA_data):
    if id not in IPA_data:   
        return None
    out = {}
    data = IPA_data[id]  
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                sc = unicodedata.name(i)
                new_string += f"[{sc}]"
            except:
                #print(f"{i} does not exist in unicode")
                pass
    out["IPA_name"] = new_string
    return out
27/165:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
27/166:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("temp_PeakMl_.txt","wb")
            out.write(PeakMl_Data)

        with open("temp_PeakMl_.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        print(f"{(time.perf_counter()-timer):0.4f} Seconds")
27/167: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test50.peakml")
27/168: add_IPA_to_PeakML("allpeaks.peakml",IPA_data_,"test.peakml")
30/1:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/2:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
import time
30/3:
def get_annotations(id,IPA_data):
    if id not in IPA_data:   
        return None
    out = {}
    data = IPA_data[id]  
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                sc = unicodedata.name(i)
                new_string += f"[{sc}]"
            except:
                print(f"{i} does not exist in unicode")
    out["IPA_name"] = new_string
    return out
30/4:
def input_string(data):
    if data == None:
        return None
    out = ""
    for i in data:
        out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
30/5:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        IPA_data_already_exists = 0

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data))
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/6:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
30/7: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
30/8:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/9:
def get_annotations(id,IPA_data):
    if id not in IPA_data:   
        return None
    out = {}
    data = IPA_data[id]  
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                sc = unicodedata.name(i)
                new_string += f"[{sc}]"
            except:
                print(f"{i} does not exist in unicode")
    out["IPA_name"] = new_string
    return out
30/10:
def input_string(data,exept):
    if data == None:
        return None
    out = ""
    for i in data:
        if i not in exept:
            out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
30/11:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #os.remove("temp_PeakMl_.txt")
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/12:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
30/13: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
30/14:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        os.remove("out_IPA_TEMP.txt")   might want to move these to after this function is used
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/15:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        os.remove("out_IPA_TEMP.txt")   #might want to move these to after this function is used
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/16:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
30/17: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
30/18: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
30/19:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        #os.remove("out_IPA_TEMP.txt")   #might want to move these to after this function is used
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
30/20: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
32/1:
import pickle
import pandas as pd
import numpy as np
import gzip
import sys
import os
import io
import shutil
import unicodedata
import time
32/2:
def get_annotations(id,IPA_data):
    if id not in IPA_data:   
        return None
    out = {}
    data = IPA_data[id]  
    out["IPA_id"] = ', '.join(str(i) for i in list(data["id"]))
    out["IPA_name"] = ', '.join(str(i) for i in list(data["name"]))
    out["IPA_formula"] = ', '.join(str(i) for i in list(data["formula"]))
    out["IPA_adduct"] = ', '.join(str(i) for i in list(data["adduct"]))
    out["IPA_mz"] = ', '.join(str(i) for i in list(data["m/z"]))
    out["IPA_charge"] = ', '.join(str(i) for i in list(data["charge"]))
    out["IPA_ppm"] = ', '.join(str(i) for i in list(data["ppm"]))
    out["IPA_isotope_pattern_score"] = ', '.join(str(i) for i in list(data["isotope pattern score"]))
    out["IPA_fragmentation_pattern_score"] = ', '.join(str(i) for i in list(data["fragmentation pattern score"]))
    out["IPA_prior"] = ', '.join(str(i) for i in list(data["prior"]))
    out["IPA_post"] = ', '.join(str(i) for i in list(data["post"]))
    out["IPA_post_Gibbs"] = ', '.join(str(i) for i in list(data["post Gibbs"]))
    out["IPA_post_chi_square_pval"] = ', '.join(str(i) for i in list(data["chi-square pval"]))
    
    check = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,()1234567890-[]_.+-'"
    new_string = ""
    for i in out["IPA_name"]:
        if i in check:
            new_string += i
        else:
            try:
                sc = unicodedata.name(i)
                new_string += f"[{sc}]"
            except:
                print(f"{i} does not exist in unicode")
    out["IPA_name"] = new_string
    return out
32/3:
def input_string(data,exept):
    if data == None:
        return None
    out = ""
    for i in data:
        if i not in exept:
            out += f'               <annotation unit="">\n                  <label>{i}</label>\n                    <value>{data[i]}</value>\n                  <valuetype>STRING</valuetype>\n             </annotation>\n'
    return out
32/4:
    def add_IPA_to_PeakML(file,IPA_Data,out_File):
        #timer = time.perf_counter()
        with gzip.open(file,"rb") as g:
            PeakMl_Data = g.read()
            out = open("out_IPA_TEMP.txt","wb")
            out.write(PeakMl_Data)

        with open("out_IPA_TEMP.txt","r") as g:
            lines = g.readlines()
    
        current_peak = None
        IPA_data_already_exists = 0
        looking_for_id = 0
        exeptions = []
        
        with open("out_IPA_TEMP.txt","w") as g:
            for line in lines:
                if looking_for_id:
                    current_peak = int(line[12:-9])
                    looking_for_id = 0
                    
                if "                    <label>id</label>" in line:
                    looking_for_id = 1

                if current_peak != None:
                    if IPA_data_already_exists != 0:
                        line = f"                   <value>{get_annotations(current_peak,IPA_Data)[IPA_data_already_exists]}</value>"
                        exeptions.append(IPA_data_already_exists)
                        IPA_data_already_exists = 0
                        

                    if "IPA" in line and "<label>" in line:
                        IPA_data_already_exists = line[12:-9]

                    if "            </annotations>" in line:
                        peak_data = input_string(get_annotations(current_peak,IPA_Data),exeptions)
                        if peak_data != None:
                            line = peak_data + line
                        current_peak = None
                        exeptions = []
                g.write(line.replace('',"[Prime]"))
            
        with open("out_IPA_TEMP.txt", 'rb') as f_in:
            with gzip.open(out_File, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
                
        with open("out_IPA_TEMP.txt","w") as g:  #issues with deleting the file so this part just deletes the content to save memory
            g.write("")
            
            
        #os.remove("out_IPA_TEMP.txt")   #might want to move these to after this function is used
        #print(f"{(time.perf_counter()-timer):0.4f} Seconds")
        #takes around 12s for 1000 peaks
32/5:
with open("example.pickle", 'rb') as handle:
    IPA_data_ = pickle.load(handle)
32/6: add_IPA_to_PeakML("sample_peak.peakml",IPA_data_,"test1.peakml")
34/1:
print("1")
print("2")
35/1:
    10%5


    def get_adj_cells(self,x,y):
        district = []
        topo = []
        g_type = []

        vals = self.get_cell_values(x+1,y)
        if vals is not None:
            district.append(vals[0])
            topo.append(vals[1])
            g_type.append(vals[2])

        vals = self.get_cell_values(x-1,y)
        if vals is not None:
            district.append(vals[0])
            topo.append(vals[1])
            g_type.append(vals[2])

        vals = self.get_cell_values(x,y+1)
        if vals is not None:
            district.append(vals[0])
            topo.append(vals[1])
            g_type.append(vals[2])

        vals = self.get_cell_values(x,y-1)
        if vals is not None:
            district.append(vals[0])
            topo.append(vals[1])
            g_type.append(vals[2])
        return [district,topo,g_type]
        

    def get_cell_values(self,x,y):
        try:
            district = self.values[x][y].district
            height = self.values[x][y].height
            g_type = self.values[x][y].g_type
            return [district,height,g_type]
        except:
            return None
    


a = generated_map(1000,1000,topo="mountains")
#print(a.values)
a.create_topography_map()
a.create_map_image(style="topo")
36/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import numpy as np
36/2:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import numpy as np
36/3: polygons = 100*np.random.random((100,2))
36/4:
polygons = 100*np.random.random((100,2))
points = Voronoi(polygons)

fig = voronoi_plot_2d(points)
fig.set_size_inches(18.5,18.5)
plt.show()
36/5:
polygons = 1000*np.random.random((100,2))
points = Voronoi(polygons)

fig = voronoi_plot_2d(points)
fig.set_size_inches(18.5,18.5)
plt.show()
36/6:
polygons = 100*np.random.random((1000,2))
points = Voronoi(polygons)

fig = voronoi_plot_2d(points)
fig.set_size_inches(18.5,18.5)
plt.show()
36/7:
polygons = 100*np.random.random((1000,2))
points = Voronoi(polygons)

fig = voronoi_plot_2d(points)
fig.set_size_inches(18.5,18.5)
#plt.show()
38/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
38/2:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/3:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/4:
def check(vert):
    for couple in vert:
        if (any(x<0 or x>size for x in couple)):
            return False
    return True
38/5:
def lloyd_relax(self, times):
    for i in range(times):
        centroids = []
        for region in self.regions:
            if (region != []):
                vert = self.vertices[region]
                if (check(vert)):
                    centroid_x = np.sum(vert[:,0])/vert.shape[0]
                    centroid_y = np.sum(vert[:,1])/vert.shape[0]
                    centroid = [centroid_x,centroid_y]
                    centroids.append(centroid)
    return Voronoi(centroids)
38/6:
lloyd = lloyd_relax(poly_map,1)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20,20)
fig.show()
38/7:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/8:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/9:
lloyd = lloyd_relax(poly_map,1)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20,20)
fig.show()
38/10:
lloyd = lloyd_relax(poly_map,3)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20,20)
fig.show()
38/11:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/12:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/13:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
38/14:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/15:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/16:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (checkVertices(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
38/17:
lloyd = lloyd_relax(poly_map, 1)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
38/18:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
38/19:
lloyd = lloyd_relax(poly_map, 1)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
38/20:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
38/21:
lloyd = lloyd_relax(poly_map, 50)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
38/22:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/23:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/24:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
38/25:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
38/26:
lloyd = lloyd_relax(poly_map, 50)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
38/27:
cell_network = networkx.Graph()
for region in lloyd:
    print(region)
38/28:
cell_network = networkx.Graph()
for region in lloyd.regions:
    print(region)
39/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
39/2:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
39/3:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
39/4:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
39/5:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
39/6:
lloyd = lloyd_relax(poly_map, 50)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
39/7: import networkx
39/8:
cell_network = networkx.Graph()
for region in lloyd.regions:
    print(region)
39/9:
size = 5
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
39/10:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
39/11:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
39/12:
lloyd = lloyd_relax(poly_map, 50)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
39/13: import networkx
39/14:
cell_network = networkx.Graph()
for region in lloyd.regions:
    region.edges
39/15:
cell_network = networkx.Graph()
for ridge in lloyd.ridge_vertices:
    print(ridge)
39/16:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

#for ridge in lloyd.ridge_vertices:
#    print(ridge)
39/17:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(region)

#for ridge in lloyd.ridge_vertices:
#    print(ridge)
39/18:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(region)

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/19:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(region)

print("________________")

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/20:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(get_edges(region))

print("________________")

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/21:
def get_edges(region:list[int]):
    return itertools.combinations(region,2)
39/22:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(get_edges(region))

print("________________")

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/23:
import networkx
import itertools
39/24:
def get_edges(region:list[int]):
    return itertools.combinations(region,2)
39/25:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(get_edges(region))

print("________________")

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/26:
def get_edges(region:list[int]):
    return list(itertools.combinations(region,2))
39/27:
cell_network = networkx.Graph()
print(len(lloyd.ridge_vertices),len(lloyd.regions))

for region in lloyd.regions:
    print(get_edges(region))

print("________________")

for ridge in lloyd.ridge_vertices:
    print(ridge)
39/28:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

print edges
39/29:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

print(edges)
39/30:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    cell_network.add_edge(edges[i][0][1])
39/31:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    print(edges[i])
    cell_network.add_edge(edges[i][0][1])
39/32:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    cell_network.add_edge(edges[i][0],edges[i][1])
39/33:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    print(edges[i])
    cell_network.add_edge(edges[i][0],edges[i][1])
39/34:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    print(edges[i])
    cell_network.add_edge(edges[i][0],edges[i][1])
39/35:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])
39/36:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    print(region)
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])
39/37:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    #print(region)
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])
39/38:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    #print(region)
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/39:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/40:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.ridge_points):
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/41:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.vertices):
    #print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/42:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.ridge_vertices):
    #print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/43:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.vertices):
    #print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/44:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.vertices):
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/45:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.vertices):
    print(region)
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/46:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.ridge_vertices):
    print(region)
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/47:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    print(region)
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
        else:
            edges[edge] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/48:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    print(region)
    print(get_edges(region))
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

#print(edges)

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    #print(edges[i])
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/49:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/50:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
39/51:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
39/52:
lloyd = lloyd_relax(poly_map, 50)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
39/53:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in get_edges(region):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/54:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
39/55:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
39/56:
size = 10
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
39/57:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
39/58:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
39/59:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
39/60:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/61:
itterations = 5

for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    print(peak)
39/62:
itterations = 5

for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    cell_network.node[peak]["height"] = 50
39/63:
itterations = 5

for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    cell_network.nodes[peak]["height"] = 50
39/64:
peaks = []

for cell in cell_network.nodes:
    if cell["height"] == 50:
        print(cell)
39/65:
peaks = []

for cell in cell_network.nodes:
    print(cell)
    if cell["height"] == 50:
        print(cell)
39/66:
peaks = []

for cell in cell_network.nodes:
    print(cell)
    #if cell["height"] == 50:
        #print(cell)
39/67:
peaks = []

for cell in cell_network.nodes:
    if cell_network.cells[cell]["height"] == 50:
        print(cell)
39/68:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
39/69:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
39/70:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
39/71:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
39/72:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
39/73:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
39/74:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
39/75:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
39/76:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
39/77:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
39/78:
itterations = 5


for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    cell_network.nodes[peak]["height"] = 50
39/79:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
39/80:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(18.5, 10.5)
39/81:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/82:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/83:
itterations = 5


for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    cell_network.nodes[peak]["height"] = 50
39/84:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/85:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/86:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/87:
itterations = 5


for i in range(itterations):
    peak = random.randint(0,cell_network.number_of_nodes())
    cell_network.nodes[peak]["height"] = 50
39/88:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/89:
itterations = 5


for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    cell_network.nodes[peak]["height"] = 50
39/90:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/91:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

networkx.draw(cell_network)
39/92:
itterations = 5


for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    cell_network.nodes[peak]["height"] = 50
39/93:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/94:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/95:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
39/96:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
39/97:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
39/98:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
39/99:
itterations = 30


for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    cell_network.nodes[peak]["height"] = 50
39/100:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/101:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

plains = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/102:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

plains = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
#plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/103:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

plains = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/104:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

plains = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/105:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

plains = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/106:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/107:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/108:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            
            


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
#ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/109:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            
            


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/110:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = cell_network.nodes[random.randint(0,cell_network.number_of_nodes())]

for i in 100:
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(cell_network.neighbors(cell))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/111:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = cell_network.nodes[random.randint(0,cell_network.number_of_nodes())]

for i in range(100):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(cell_network.neighbors(cell))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/112:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = cell_network.nodes[random.randint(0,cell_network.number_of_nodes())]

for i in range(100):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/113:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = cell_network.nodes[random.randint(0,cell_network.number_of_nodes())]
print(cell)
for i in range(100):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/114:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = random.randint(0,cell_network.number_of_nodes())
print(cell)
for i in range(100):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(5, 5)
39/115:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = random.randint(0,cell_network.number_of_nodes())
print(cell)
for i in range(100):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/116:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = random.randint(0,cell_network.number_of_nodes())
print(cell)
for i in range(1000):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/117:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = random.randint(0,cell_network.number_of_nodes())
print(cell)
for i in range(1000):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/118:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


cell = random.randint(0,cell_network.number_of_nodes())
print(cell)
for i in range(1000):
    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
#ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/119:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if lloyd.regions[cell].furthrst_site:
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/120:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.regions[cell]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/121:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()
fig.set_size_inches(10, 10)
39/122:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color((0,255,0))

fig.set_size_inches(10, 10)
39/123:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
            #peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
39/124:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
39/125:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))

peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/1:
peaks = []
river = []
plains = []
40/2:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/3:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/4:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
40/5:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
40/6:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
40/7:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
40/8:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
40/9:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
40/10:
import networkx
import itertools
40/11:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
40/12:
itterations = 30


for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    cell_network.nodes[peak]["height"] = 50
40/13:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/14:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/15:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/16:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/17:
peaks = []
river = []
plains = []
40/18:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/19:
itterations = 30


for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
40/20:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/21:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/22:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
40/23:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
40/24:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
40/25:
itterations = 30


for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
40/26:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []



for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 10:
        if check(lloyd.vertices[lloyd.regions[cell]]):
            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/27:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/28:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/29:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/30:
itterations = 30


for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
40/31:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/32:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/33:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
        #    peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        #    for j in cell_network.neighbors(i):
        #        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/34:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/35:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
        #    peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        #    for j in cell_network.neighbors(i):
        #        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/36:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/37:
sea = []

for cell in cell_network.nodes:
    if (check(lloyd.vertices[lloyd.regions[cell]])) is not True:
        sea.append(cell)

print(sea)
40/38:
sea = []

for cell in cell_network.nodes:
    if (check(lloyd.vertices[lloyd.regions[cell]])) is not True:
        sea.append(cell)
40/39:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] == -10
            convert_to_sea(i,counter-1)
40/40:
fill_num = 5

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/41:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/42:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/43:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/44:
peaks = []
river = []
plains = []
40/45:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/46:
fill_num = 5

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/47:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/48:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        print(cell)
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/49:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/50:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
40/51:
fill_num = 5

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/52:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/53:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/54:
fill_num = 10

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/55:
fill_num = 6

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/56:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/57:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/58:
fill_num = 6

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/59:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
40/60:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/61:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/62:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
40/63:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
40/64:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
40/65:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
40/66:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
40/67:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = 10,g_type = "water")
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
40/68:
itterations = 30


for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
40/69:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
40/70:
fill_num = 6

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/71:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/72:
peaks = []
river = []
plains = []
40/73:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/74:
fill_num = 8

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/75:
fill_num = 7

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
40/76:
sea = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == -10:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            sea.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/77:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        #for i in cell_network.neighbors(cell):
        #    peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        #    for j in cell_network.neighbors(i):
        #        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
40/78:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/79:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
40/80:
itterations = 30

#peak generation

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
40/81:
def elevation_decrease(cell,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            cell_network.nodes[n]["height"] = elevation
            complete_cells.append(n)
            elevation_decrease(n,complete_cells,elevation-1)
40/82:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
40/83:
def elevation_decrease(cell,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            cell_network.nodes[n]["height"] = elevation
            complete_cells.append(n)
            elevation_decrease(n,complete_cells,elevation-1)
40/84:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/85:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
40/86:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/87:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height in groups:
        groups[height].append(i)
    else:
        groups[height] = [i]

print(groups)
40/88:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height in groups:
        groups[height].append(i)
    else:
        groups[height] = [i]

print(groups[49])
40/89:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/90:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    print(cell)
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
40/91:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/92:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    print(cell)
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
40/93:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/94:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
40/95:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/96:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height in groups:
        groups[height].append(i)
    else:
        groups[height] = [i]

print(groups[49])
40/97:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for i in collections:
    ax.add_collection(i)
    i.set_color([(random.randint(0,255),random.randint(0,255),random.randint(0,255))])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/98:
print(plains)
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/99:
print(peaks)
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
40/100:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height in groups:
        groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
    else:
        groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]

print(groups[49])
40/101:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height in groups:
        groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
    else:
        groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
40/102:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for i in collections:
    ax.add_collection(i)
    i.set_color([(random.randint(0,255),random.randint(0,255),random.randint(0,255))])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/103:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
40/104:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for i in collections:
    ax.add_collection(i)
    i.set_color([(random.randint(0,255),random.randint(0,255),random.randint(0,255))])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/105:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([0,0,count)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/106:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/107:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*2)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/108:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/109:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
40/110:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
40/111:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
40/112:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/113:
fig, ax = plt.subplots(2)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
40/114:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
41/1:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
41/2:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
41/3:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
41/4:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
41/5:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
41/6:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
41/7:
lloyd = lloyd_relax(poly_map, 10)
fig = voronoi_plot_2d(lloyd)
fig.set_size_inches(20, 20)
plt.show()
41/8:
import networkx
import itertools
41/9:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
41/10:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
41/11:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
41/12:
fill_num = 7

for cell in cell_network.nodes:
    if(check(lloyd.vertices[lloyd.regions[cell]])) is False:
        convert_to_sea(cell,random.randint(0,fill_num))
41/13:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/14:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/15:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/16:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
    ax.autoscale_view()
    fig.set_size_inches(10, 10)
41/17:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*2,0)])
ax.autoscale_view()
fig.set_size_inches(10, 10)
41/18:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/19:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,2,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/20:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[10])
41/21:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/22:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/23:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

#ax.autoscale_view()
#fig.set_size_inches(10, 10)
41/24:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
#fig.set_size_inches(10, 10)
41/25:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/26:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

#ax.autoscale_view()
fig.set_size_inches(10, 10)
41/27:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/28:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    #i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/29:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/30:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/31:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/32:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color([(int(counter),0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/33:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color([(int(count),0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/34:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

colours = []
for i in range(60):

    colours.append[[(i*3,0,0)]]

for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color(colours[count])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/35:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

colours = []
for i in range(60):

    colours.append([(i*3,0,0)])

for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color(colours[count])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/36:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

colours = []
for i in range(60):

    colours.append([(i*3,0,0)])

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color(colours[count])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/37:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

colours = []
for i in range(60):
    colours.append([(i*2,0,0)])

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color(colours[count])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/38:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))

colours = []
for i in range(60):
    colours.append([(2,0,0)])

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color(colours[count])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/39:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/40:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
41/41:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)

peint(peaks_locs)
41/42:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)

print(peaks_locs)
41/43:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
41/44:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
41/45:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)

print(peaks_locs)
41/46:
def convert_to_sea(cell:int,counter:int) -> None:
    if counter > 0:
        for i in cell_network.neighbors(cell):
            cell_network.nodes[cell]["height"] = -10
            convert_to_sea(i,counter-1)
41/47:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/48:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/49:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/50:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/51:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]

print(groups[50])
41/52:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/53: lloyd = lloyd_relax(poly_map, 10)
41/54:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)

print(peaks_locs)
41/55:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/56:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/57:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/58:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]

print(groups[50])
print(groups[49])
41/59:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/60:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/61:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/62:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                complete_cells = elevation_decrease(n,complete_cells,elevation-1)
    return complete_cells
41/63:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/64:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                complete_cells = elevation_decrease(n,complete_cells,elevation-1)
                return complete_cells
41/65:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/66:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/67:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/68:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/69:
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/70:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/71:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/72:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)

print(peaks_locs)
41/73:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/74:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/75:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/76:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/77:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/78:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/79:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,4)
41/80:
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/81:
fig, ax = plt.subplots(1)
fig.clf()
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/82:
fig, ax = plt.subplots(1)
fig.clf()
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/83:
fig, ax = plt.subplots(1)
#fig.clf()
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/84:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/85:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 49:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/86:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/87:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 50:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/88:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 49:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/89:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 48:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/90:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 49:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/91:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 49:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/92:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/93:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 30:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/94:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/95:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size+1 for x in couple)):
            return False
    return True
41/96:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/97:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/98:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
            for j in cell_network.neighbors(i):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
41/99:
print(peaks)
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)
sea_collection = PatchCollection(sea)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.add_collection(sea_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
41/100:
print(peaks)
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
41/101:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
41/102:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            if(check(lloyd.vertices[lloyd.regions[i]])):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
                for j in cell_network.neighbors(i):
                    if(check(lloyd.vertices[lloyd.regions[j]])):
                        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
41/103:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
41/104:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/105:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
41/106:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/107:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
41/108:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            if(check(lloyd.vertices[lloyd.regions[i]])):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
                for j in cell_network.neighbors(i):
                    if(check(lloyd.vertices[lloyd.regions[j]])):
                        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
41/109:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                if elevation == 50:
                    print("!!!")
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/110:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
41/111:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/112:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(height[50])
41/113:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/114:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                if elevation == 50: print("!!!")
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/115:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/116:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/117:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/118:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/119:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/120:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
41/121:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
41/122:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/123:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/124:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
41/125:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
41/126:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                if elevation == 50: print("!!!")
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/127:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/128:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/129:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/130:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49)
41/131:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/132:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/133:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups)
41/134:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
41/135:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/136:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(count,count,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/137:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(255-count,,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/138:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(255-count,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/139:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(100-count,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/140:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(int(100-count),0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/141:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/142:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/143:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > -1:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/144:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/145:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/146:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/147:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/148:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                if elevation == 50: print("!!!")
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/149:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/150:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/151:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[50])
41/152:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/153:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/154:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups)
41/155:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height == 50: print(i)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
41/156:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
41/157:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
41/158:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/159:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/160:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (cell not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            print(n)
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/161:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/162:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/163:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells) and check(lloyd.vertices[lloyd.regions[n]]):
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/164:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/165:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/166:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/167:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*2)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/168:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
41/169: print(cell_network.neighbors(3756))
41/170:
for i in cell_network.neighbors(3756):
    print(i)
41/171:
print(3756)
print("_____")

cells_list = [3756]
for i in cell_network.neighbors(3756):
    print(i)

print("_____")
41/172:
print(3756)
print("_____")

cells_list = [3756]
for i in cell_network.neighbors(3756):
    print(i)

print("_____")

for i in cells_list:
    for j in cell_network.neighbors(i):
        if j not in cells_list:
            print(j)
41/173:
print(3756)
print("_____")

cells_list = [3756]
for i in cell_network.neighbors(3756):
    print(i)
    cells_list.append(i)

print("_____")

for i in cells_list:
    for j in cell_network.neighbors(i):
        if j not in cells_list:
            print(j)
41/174:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells):
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/175:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells):
            if cell_network.nodes[n]["height"] <= elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/176:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/177:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/178:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/179:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/180:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
41/181:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/182:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/183:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/184:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
41/185:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        print(n)
        if (n not in complete_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/186:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/187:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        print(n)
        if (n not in complete_cells):
            print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/188:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
41/189:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        print(n)
        print(complete_cells)
        if (n not in complete_cells):
            print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
41/190:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
42/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
42/2:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
42/3:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
42/4:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
42/5:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
42/6: lloyd = lloyd_relax(poly_map, 10)
42/7:
import networkx
import itertools
42/8:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
42/9:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
42/10:
print(3756)
print("_____")

cells_list = [3756]
for i in cell_network.neighbors(3756):
    print(i)
    cells_list.append(i)

print("_____")

for i in cells_list:
    for j in cell_network.neighbors(i):
        if j not in cells_list:
            print(j)
42/11:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        print(n)
        print(complete_cells)
        if (n not in complete_cells):
            print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
42/12:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        #print(n)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
42/13:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
42/14:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
42/15:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
42/16:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
42/17:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        print(n,complete_cells)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
42/18:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/1:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/2:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
43/3:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
43/4:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
43/5:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
43/6:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
43/7: lloyd = lloyd_relax(poly_map, 10)
43/8:
import networkx
import itertools
43/9:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
43/10:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/11:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/12:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/13:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    print(lloyd.vertices[lloyd.regions[i]])
    if check(lloyd.vertices[lloyd.regions[i]]):
        peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/14:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/15:
print(3756)
print("_____")

cells_list = [3756]
for i in cell_network.neighbors(3756):
    print(i)
    cells_list.append(i)

print("_____")

for i in cells_list:
    for j in cell_network.neighbors(i):
        if j not in cells_list:
            print(j)
43/16:
print(peaks_locs[0])
print("_____")

cells_list = [peaks_locs[0]]
for i in cell_network.neighbors(peaks_locs[0]):
    print(i)
    cells_list.append(i)

print("_____")

for i in cells_list:
    for j in cell_network.neighbors(i):
        if j not in cells_list:
            print(j)
43/17:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    for n in cell_network.neighbors(cell):
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1)
43/18:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/19:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
43/20:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int,couter):
    for n in cell_network.neighbors(cell):
        if couter == 1:
            print(n)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1,0)
43/21:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/22:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int,couter):
    for n in cell_network.neighbors(cell):
        if couter == 1:
            print(cell,n)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1,0)
43/23:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/24: print(peaks_locs)
43/25:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/26: print(peaks_locs)
43/27:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/28:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int,couter):
    print(1)
    for n in cell_network.neighbors(cell):
        if couter == 1:
            print(cell,n)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                complete_cells.append(n)
                elevation_decrease(n,complete_cells,elevation-1,0)
43/29: print(peaks_locs)
43/30:
import networkx
import itertools
import copy
43/31:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int,couter):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if couter == 1:
            print(cell,n)
        if (n not in complete_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1,0)
43/32: print(peaks_locs)
43/33:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/34: print(peaks_locs)
43/35:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/36:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
43/37:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups[49])
43/38:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/39:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int,couter):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if couter == 1:
            print(cell,n)
        if (n not in new_cells):
            #print("___")
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1,0)
43/40: print(peaks_locs)
43/41:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/42:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups[49])
43/43:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/44:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49,1)
43/45:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/46: print(peaks_locs)
43/47:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,49,1)
43/48:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/49:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/50:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/51:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/52:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            print(n)
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/53:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/54:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            print(n)
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/55:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50,1)
43/56:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/57:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        print(n)
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/58:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/59:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        print(n)
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                print(new_cells)
                elevation_decrease(n,new_cells,elevation-1)
43/60:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/61:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        print(n)
        print(new_cells)
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                print(new_cells)
                elevation_decrease(n,new_cells,elevation-1)
43/62:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/63:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        print(n)
        print(new_cells)
        if (n not in new_cells):
            print("_____")
            print(n)
            print(new_cells)
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                print(new_cells)
                elevation_decrease(n,new_cells,elevation-1)
43/64:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/65:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
43/66:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/67:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/68:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/69:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/70:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/71:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count+20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/72:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/73:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    print(count)
    ax.add_collection(i)
    i.set_color([(0,0,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/74:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/75:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/76:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        print(peak)
        peaks_locs.append(peak)

print(peaks_locs)
43/77:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
43/78:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
43/79: print(peaks_locs)
43/80:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/81:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/82:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/83:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/84:
itterations = 40

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
43/85:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
43/86:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
43/87:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/88:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/89:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
43/90:
size = 10000
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
44/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
44/2:
size = 1000
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
44/3:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
44/4:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
44/5:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
44/6: lloyd = lloyd_relax(poly_map, 2)
44/7:
import networkx
import itertools
import copy
44/8:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
44/9:
itterations = 400

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
44/10:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
44/11:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
44/12:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/13:
fig.clf()
fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/14:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/15:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/16:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
44/17:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
44/18: lloyd = lloyd_relax(poly_map, 2)
44/19:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
44/20:
itterations = 400

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
44/21:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
44/22:
itterations = 40

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
44/23:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
44/24:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/25:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/26:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/27:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/28:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/29:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 30:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/30:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/31:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
44/32:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
44/33:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = 50
        peaks_locs.append(peak)
44/34:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
44/35:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/36:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
44/37:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/38:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    #i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/39:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/40:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(heights)
44/41:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups)
44/42:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(len(groups49))
44/43:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/44: print(peaks_locs)
44/45:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,50)
44/46:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/47:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*5 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/48:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
44/49:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
44/50:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
44/51:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
44/52:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/53:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
44/54:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(len(groups[49]))
44/55:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(len(groups[49]))
44/56:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/57:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/58:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
44/59:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
44/60: print(peaks_locs)
44/61:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
44/62:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
44/63:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(len(groups[49]))
44/64:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
print(groups)
44/65:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
44/66:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
45/1:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
45/2:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
45/3:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
45/4:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
45/5:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
45/6: lloyd = lloyd_relax(poly_map, 2)
45/7:
import networkx
import itertools
import copy
45/8:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
45/9:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/10:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
45/11:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
45/12:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
45/13:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
45/14:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
45/15:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 40:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/16:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/17:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 0:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/18:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/19:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 00:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/20:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 1:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/21:

fig, ax = plt.subplots(1)
collections = []
for i in groups:
    if i > 5:
        collections.append(PatchCollection(groups[i]))


for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,count*10 + 5)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/22:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*10 + 5),0])

ax.add_collection(sea)
sea.set_color(0,0,20)

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/23:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*10 + 5),0])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/24:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5),0])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/25:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/26:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

#ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/27:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 10:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

#ax.add_collection(sea)
#sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/28:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

#ax.add_collection(sea)
#sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/29:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/30:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        sea.append(PatchCollection(groups[i]))

print(collections[1])

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/31:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        sea.append(PatchCollection(groups[i]))

print(collections[1])
print(sea)

for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

ax.add_collection(sea)
sea.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/32:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/33:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 0:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/34:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/35:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 3:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/36:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 2:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/37:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    elif i > 3:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/38:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 3:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/39:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    elif i > 3:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/40:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
45/41:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
45/42: lloyd = lloyd_relax(poly_map, 2)
45/43:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
45/44:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/45:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
45/46:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
45/47:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
45/48:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    elif i > 3:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/49:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/50:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    elif i > 5:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,20,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/51:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/52:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/53:
itterations = 2

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/54:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
45/55:
itterations = 2

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/56:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
45/57:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
45/58:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
45/59:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
45/60:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
45/61:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
45/62:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
45/63:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
45/64:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
45/65:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
46/1:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    #i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
46/2:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
46/3:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
46/4:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
46/5:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
46/6:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
46/7: lloyd = lloyd_relax(poly_map, 2)
46/8:
import networkx
import itertools
import copy
46/9:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
46/10:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
46/11:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
46/12:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
46/13:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
46/14:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
46/15:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
46/16:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    #i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
46/17:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            if(check(lloyd.vertices[lloyd.regions[i]])):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
                for j in cell_network.neighbors(i):
                    if(check(lloyd.vertices[lloyd.regions[j]])):
                        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
46/18:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
46/19:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for i in sea:
    ax.add_collection(i)
    i.set_color([(0,0,20)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
   1:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,200-count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
   2:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
   3:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
   4:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
   5:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
   6:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
   7: lloyd = lloyd_relax(poly_map, 2)
   8:
import networkx
import itertools
import copy
   9:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
  10:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
  11:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
  12:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
  13:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
  14:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
  15:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
  16:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,count*5 + 5,0)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,200-count)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  17:
peaks = []

for cell in cell_network.nodes:
    if cell_network.nodes[cell]["height"] == 50:
        print(cell)
        if(check(lloyd.vertices[lloyd.regions[cell]])):
            peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
        for i in cell_network.neighbors(cell):
            if(check(lloyd.vertices[lloyd.regions[i]])):
                peaks.append(Polygon(lloyd.vertices[lloyd.regions[i]]))
                for j in cell_network.neighbors(i):
                    if(check(lloyd.vertices[lloyd.regions[j]])):
                        peaks.append(Polygon(lloyd.vertices[lloyd.regions[j]]))
            

river = []


#cell = random.randint(0,cell_network.number_of_nodes())
#print(cell)
#for i in range(1000):
#    peaks.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))   
#    cell = random.choice(list(cell_network.neighbors(cell)))


plains = []


#
#for cell in cell_network.nodes:
#    if cell_network.nodes[cell]["height"] == 10:
#        if check(lloyd.vertices[lloyd.regions[cell]]):
#            plains.append(Polygon(lloyd.vertices[lloyd.regions[cell]]))
  18:
peak_collection = PatchCollection(peaks)
plains_collection = PatchCollection(plains)

fig, ax = plt.subplots(1)
ax.add_collection(peak_collection)
ax.add_collection(plains_collection)
ax.autoscale_view()

peak_collection.set_color([(0,255,0)])

fig.set_size_inches(10, 10)
  19:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  20:
itterations = 15

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
  21:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
  22:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
  23:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
  24:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  25:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  26:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  27:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
  28:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
  29:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
  30:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
  31:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
  32:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
  33:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  34:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  35:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*5,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  36:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,200-count*((5)**2)**1/2,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  37:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    print(200-count*2)
    i.set_color([(0,200-count*2,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  38:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    print(200-count*2)
    #i.set_color([(0,200-count*2,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  39:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    print(200-count*2)
    i.set_color([(0,200-count*2,0)])

ax.autoscale_view()
fig.set_size_inches(10, 10)
  40:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    print(200-count*2)
    try:
        i.set_color([(0,200-count*2,0)])
    except:
        pass

ax.autoscale_view()
fig.set_size_inches(10, 10)
  41:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    print(200-count*2)
    i.set_color([(0,200,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  42:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,200-count*2,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  43:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,3,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  44:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  45:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,1,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  46:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,2,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  47:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,2,1)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  48:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,1,1)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  49:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,1,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  50:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,10,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  51:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,2,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  52:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    #i.set_color([(0,200-count*2,0)])
    i.set_color([(0,0.2,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  53:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*2)/200,0)])
    i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  54:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*2)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  55:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*2)/100,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  56:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*2)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  57:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 20:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  58:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 15:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  59:

fig, ax = plt.subplots(1)
collections = []
sea = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  60:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color([(1,0,0)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  61:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color([(255,255,0)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  62:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color([(255,255,204)])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  63:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["FFFFCC"])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  64:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFFCC"])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  65:

fig, ax = plt.subplots(1)
collections = []
sea = []
beach = []
for i in groups:
    if i > 25:
        collections.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    else:
        sea.append(PatchCollection(groups[i]))



for count,i in enumerate(collections):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(sea):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])


ax.autoscale_view()
fig.set_size_inches(10, 10)
  66:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color("#A0A0A0")


ax.autoscale_view()
fig.set_size_inches(10, 10)
  67:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#A0A0A0","#A0A0A0","#C0C0C0","#C0C0C0"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color("#A0A0A0")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  68:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#A0A0A0","#A0A0A0","#C0C0C0","#C0C0C0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  69:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C0C0C0","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  70:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  71:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  72:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  73:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
  74:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
  75:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
  76:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
  77:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
  78: lloyd = lloyd_relax(poly_map, 2)
  79:
import networkx
import itertools
import copy
  80:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
  81:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
  82:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
  83:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
  84:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
  85:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
  86:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
  87:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
  88:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
  89:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
  90:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
  91:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
  92:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
  93: lloyd = lloyd_relax(poly_map, 2)
  94:
import networkx
import itertools
import copy
  95:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
  96:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
  97:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
  98:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
  99:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 100:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 101:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 102:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 103:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 104:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 105:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 106:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 107:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 108: lloyd = lloyd_relax(poly_map, 2)
 109:
import networkx
import itertools
import copy
 110:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 111:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 112:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 113:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 114:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 115:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 116:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 117:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 118:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(["#FFFF99"])
    print(count)

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

mountains_top_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 119:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])
    print(count)

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

mountains_top_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 120:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 121:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 122:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 123:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 124:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 125: lloyd = lloyd_relax(poly_map, 2)
 126:
import networkx
import itertools
import copy
 127:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 128:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 129:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 130:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 131:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 132:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 133:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 134:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])
    print(count)

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

mountains_top_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 135:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])
    print(count)

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

mountains_top_colours = ["#C9C9C9","#C0C0C0","#A0A0A0","#A0A0A0","#606060","","",""]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 136:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])
    print(count)

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])
    print(count)

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color("#C9C9C9")
    print(count)


ax.autoscale_view()
fig.set_size_inches(10, 10)
 137:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 138:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 139:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 140:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 141:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 142: lloyd = lloyd_relax(poly_map, 2)
 143:
import networkx
import itertools
import copy
 144:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 145:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 146:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 147:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 148:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 149:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 150:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 151:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])


ax.autoscale_view()
fig.set_size_inches(10, 10)
 152:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 153:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 154:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 155:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 156:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 157: lloyd = lloyd_relax(poly_map, 2)
 158:
import networkx
import itertools
import copy
 159:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 160:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 161:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 162:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 163:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 164:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 165:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 166:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])


ax.autoscale_view()
fig.set_size_inches(10, 10)
 167:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])


ax.autoscale_view()
fig.set_size_inches(10, 10)
 168:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    PRINT(COUNT)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 169:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 170:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 171:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#909090"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 172:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#909090"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    #i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 173:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#808080"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    #i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 174:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_base = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >15:
        collections.append(PatchCollection(groups[i]))
    elif i > 10:
        mountains_base.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_base_colours = ["#808080","#707070","#606060","#505050","#404040"]
for count,i in enumerate(mountains_base):
    ax.add_collection(i)
    i.set_color(mountains_base_colours[count])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#202020","#101010"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    #i.set_color(mountains_top_colours[count])
    print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 175:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#202020","#101010"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 176:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 177:
size = 110
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 178:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 179:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 180:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 181: lloyd = lloyd_relax(poly_map, 2)
 182:
import networkx
import itertools
import copy
 183:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 184:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 185:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 186:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 187:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 188:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 189:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 190:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#202020","#101010"]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 191:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#202020","#101010"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 192:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 193:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 194:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 195:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 196:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 197:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 198: lloyd = lloyd_relax(poly_map, 2)
 199:
import networkx
import itertools
import copy
 200:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 201:
itterations = 10

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 202:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 203:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 204:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 205:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 206:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 207:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 208:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 209:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 210:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 211:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 212:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 213: lloyd = lloyd_relax(poly_map, 2)
 214:
import networkx
import itertools
import copy
 215:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 216:
itterations = 50

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 217:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 218:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 219:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 220:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 221:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 222:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))



for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 223:
fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains = []
 224:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
 225:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 226:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 227:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color([(0,(200-count*5)/200,0)])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 228:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(hills))
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color([(0,(200-count*5)/200,0)])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 229:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(hills))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color([(0,(200-count*5)/200,0)])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 230:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(hills))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours(count))











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 231:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(hills))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 232:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])











    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 233:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

mountains_top_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])








    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 234:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])








    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 235:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 236:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 237:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 238:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 239:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 240:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 241:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 242: lloyd = lloyd_relax(poly_map, 2)
 243:
import networkx
import itertools
import copy
 244:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 245:
itterations = 50

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(0,50)
        peaks_locs.append(peak)
 246:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 247:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 248:
for peak in peaks_locs:
    print(peak, cell_network.nodes[peak]["height"])
 249:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 250:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 251:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 252:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 253:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 254:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 255:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 256:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 257:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 258:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 259: lloyd = lloyd_relax(poly_map, 2)
 260:
import networkx
import itertools
import copy
 261:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 262:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 263:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 264:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 265:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 266:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 267:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 268:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 269:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 270:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 271:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 272:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 273:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 274:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 275:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 276: lloyd = lloyd_relax(poly_map, 2)
 277:
import networkx
import itertools
import copy
 278:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 279:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 280:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 281:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 282:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 283:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 284:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 285:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 286:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 287:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 288:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 2:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 289:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 290:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 291:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 292:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 293:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 294:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 295: lloyd = lloyd_relax(poly_map, 2)
 296:
import networkx
import itertools
import copy
 297:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 298:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 299:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 300:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 301:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 302:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 303:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 304:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 305:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 306:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 307:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 308:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 309:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 310:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 311:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 312: lloyd = lloyd_relax(poly_map, 2)
 313:
import networkx
import itertools
import copy
 314:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 315:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 316:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 317:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 318:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 319:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 320:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 321:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 322:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 323:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 324:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
print(len(beach))
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

print(len(water))
for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 325:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    print(i)
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
print(len(beach))
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

print(len(water))
for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 326:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    print(i)
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 327:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    print(i)
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(deep)

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 328:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    print(i)
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

print(len(plains))
hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 329:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", sum(len(mountains),len(hills),len(plains),len(beach),len(deep)))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 330:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")






    
ax.autoscale_view()
fig.set_size_inches(10, 10)
 331:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
        print(sea)
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 332:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
        print(i)
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 333:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i >10:
        collections.append(PatchCollection(groups[i]))
        print(i)
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 334:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 335:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 336:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 337:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 338:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 339:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 340: lloyd = lloyd_relax(poly_map, 2)
 341:
import networkx
import itertools
import copy
 342:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 343:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 344:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 345:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 346:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 347:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 348:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 349:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 350:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 8:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 351:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
        print(i)
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 352:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 353:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if height < 0:
        print(height)
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 354:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 355:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 80:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 356:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 357:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 358:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 359:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 360:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 361:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 362:
fig = voronoi_plot_2d(poly_map)
fig.set_size_inches(20,20)
fig.show()
 363:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 364:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 365: lloyd = lloyd_relax(poly_map, 2)
 366:
import networkx
import itertools
import copy
 367:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 368:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 369:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 370:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 371:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 80:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 372:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 373:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 374:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 375:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 376:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 377:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 378:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 379:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 380:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 381:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 382:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 383: lloyd = lloyd_relax(poly_map, 2)
 384:
import networkx
import itertools
import copy
 385:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 386:
itterations = 6

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 387:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 388:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 389:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 80:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 390:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 391:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 392:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 393:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 394:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 395:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 396:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 397:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 398:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 399:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 400: lloyd = lloyd_relax(poly_map, 2)
 401:
import networkx
import itertools
import copy
 402:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 403:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 404:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 405:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 406:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 80:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 407:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 408:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 409:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 410:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 411:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 412:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 413:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 414:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 415:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 416:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 417:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 418: lloyd = lloyd_relax(poly_map, 2)
 419:
import networkx
import itertools
import copy
 420:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 421:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 422:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 423:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 424:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 425:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 426:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 427:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 428:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 429:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 430:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 431:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 432:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 433:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 434:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 435:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 436: lloyd = lloyd_relax(poly_map, 2)
 437:
import networkx
import itertools
import copy
 438:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 439:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 440:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 441:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 442:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
        else:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation + 1
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 443:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 444:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 445:
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)
 446:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = ["#FFFF66","#FFFF88","#FFFF88","#FFFFAA","#FFFFAA"]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 447:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 448:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = ["#00AA00","#00AA00","#00AA00","#00AA00","#00CC00","#00CC00","#00CC00","#00CC00","#00EE00","#00EE00","#00EE00","#00EE00","#33FF33","#33FF33","#33FF33","#33FF33"]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 449:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 450:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])
    print(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 451:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 452:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])
    print(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 453:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 454:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 455:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 456:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 457:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 458: lloyd = lloyd_relax(poly_map, 2)
 459:
import networkx
import itertools
import copy
 460:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 461:
itterations = 30

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 462:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 463:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 464:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 465:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 466:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 467:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 468:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))
print(len(mountains),len(hills),len(plains),len(beach),len(deep))
print(len(groups), " | ", len(mountains)+len(hills)+len(plains)+len(beach)+len(deep))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])
    print(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 469:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 470:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 471:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 472:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 473:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 474:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 475: lloyd = lloyd_relax(poly_map, 2)
 476:
import networkx
import itertools
import copy
 477:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 478:
itterations = 50

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 479:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 480:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 481:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 482:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 483:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 484:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 485:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 486:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 487:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 488:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 489:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 490:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 491:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 492: lloyd = lloyd_relax(poly_map, 2)
 493:
import networkx
import itertools
import copy
 494:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 495:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(20,50)
        peaks_locs.append(peak)
 496:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 497:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 498:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 499:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 500:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 501:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 502:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 503:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 504:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 505:
size = 200
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 506:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 507:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 508:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 509: lloyd = lloyd_relax(poly_map, 2)
 510:
import networkx
import itertools
import copy
 511:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 512:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 513:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 514:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 515:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 516:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 517:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 518:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 519:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 520:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 521:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 522:
size = 500
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 523:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 524:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 525:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 526: lloyd = lloyd_relax(poly_map, 2)
 527:
import networkx
import itertools
import copy
 528:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 529:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 530:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 531:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 532:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 533:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 534:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 535:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 536:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 537:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 538:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 539:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 540:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 541:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 542:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 543: lloyd = lloyd_relax(poly_map, 2)
 544:
import networkx
import itertools
import copy
 545:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 546:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 547:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 548:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 549:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 550:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 551:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 552:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 553:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 554:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 555:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 556:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 557:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 558:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 559:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 560: lloyd = lloyd_relax(poly_map, 2)
 561:
import networkx
import itertools
import copy
 562:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 563:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 564:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 565:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 566:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 567:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 568:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 569:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 570:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 571:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 572:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 573:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 574:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 575:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 576:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 577: lloyd = lloyd_relax(poly_map, 2)
 578:
import networkx
import itertools
import copy
 579:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 580:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 581:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 582:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 583:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
            else:
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 584:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 585:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 586:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 587:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 588:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 589:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 590:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 591:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 592:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 593:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 594: lloyd = lloyd_relax(poly_map, 2)
 595:
import networkx
import itertools
import copy
 596:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 597:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 598:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 599:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 600:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if (n not in new_cells):
                if cell_network.nodes[n]["height"] < elevation:
                    cell_network.nodes[n]["height"] = elevation
                    new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 601:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 602:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 603:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 604:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 605:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 606:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 607:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 608:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 609:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 610:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 611: lloyd = lloyd_relax(poly_map, 2)
 612:
import networkx
import itertools
import copy
 613:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 614:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 615:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 616:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 617:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        if n in new_cells:
            elevation_decrease(n,new_cells,elevation-1)
 618:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 619:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 620:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 621:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 622:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 623:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 624:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 625:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 626:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 627:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 628:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 629: lloyd = lloyd_relax(poly_map, 2)
 630:
import networkx
import itertools
import copy
 631:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 632:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 633:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 634:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 635:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if random.randint(0,100) > 20:
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 636:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 637:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 638:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 639:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 640:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 641:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 642:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 643:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 644:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 645:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 646: lloyd = lloyd_relax(poly_map, 2)
 647:
import networkx
import itertools
import copy
 648:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 649:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 650:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 651:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 652:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 653:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 654:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 655:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 656:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 657:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 658:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] > elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 659:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 660:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 661:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 662:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 663:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 664: lloyd = lloyd_relax(poly_map, 2)
 665:
import networkx
import itertools
import copy
 666:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 667:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 668:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 669:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 670:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] > elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 671:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 672:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
 673:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 674:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 675:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 676:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 677:
size = 100
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 678:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 679:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 680:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 681: lloyd = lloyd_relax(poly_map, 2)
 682:
import networkx
import itertools
import copy
 683:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 684:
itterations = 100

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 685:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 686:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 687:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 688:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 689:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 690:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 691:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 692:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 693:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 694:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 695:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 696:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 697:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 698: lloyd = lloyd_relax(poly_map, 2)
 699:
import networkx
import itertools
import copy
 700:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 701:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 702:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 703:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 704:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 705:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 706:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 707:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 708:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 709:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 710:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 711:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 712:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 713:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 714:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 715: lloyd = lloyd_relax(poly_map, 2)
 716:
import networkx
import itertools
import copy
 717:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 718:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 719:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 720:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 721:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 722:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 723:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 724:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 725:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 726:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 727:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 728:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 729:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 730:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 731:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 732: lloyd = lloyd_relax(poly_map, 2)
 733:
import networkx
import itertools
import copy
 734:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 735:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 736:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 737:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 738:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 739:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 740:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 741:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 742:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 743:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 744:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 745:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 746:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 747:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 748:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 749: lloyd = lloyd_relax(poly_map, 2)
 750:
import networkx
import itertools
import copy
 751:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 752:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 753:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 754:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 755:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 756:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 757:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 758:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 759:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 760:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 761:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 762:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 763:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 764:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 765:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 766: lloyd = lloyd_relax(poly_map, 2)
 767:
import networkx
import itertools
import copy
 768:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 769:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 770:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 771:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 772:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 773:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 774:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 775:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 776:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 777:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 778:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 779:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 780:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 781:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 782:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 783: lloyd = lloyd_relax(poly_map, 2)
 784:
import networkx
import itertools
import copy
 785:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 786:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 787:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 788:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 789:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 790:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 791:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 792:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 793:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 794:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 795:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 796:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 797:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 798:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 799:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 800: lloyd = lloyd_relax(poly_map, 2)
 801:
import networkx
import itertools
import copy
 802:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 803:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 804:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 805:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 806:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 807:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 808:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 809:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 810:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 811:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 812:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 813:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 814:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 815:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 816:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 817: lloyd = lloyd_relax(poly_map, 2)
 818:
import networkx
import itertools
import copy
 819:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 820:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 821:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 822:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 823:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 824:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 825:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 826:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 827:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 828:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 829:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 830:
size = 20
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 831:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 832:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 833:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 834: lloyd = lloyd_relax(poly_map, 2)
 835:
import networkx
import itertools
import copy
 836:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 837:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 838:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 839:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 840:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 841:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 842:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 843:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 844:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 845:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 846:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 847:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 848:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 849:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 850:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 851:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 852: lloyd = lloyd_relax(poly_map, 2)
 853:
import networkx
import itertools
import copy
 854:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 855:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 856:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 857:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 858:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 859:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 860:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 861:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 862:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 863:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 864:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 865:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 866:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 867:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 868:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 869: lloyd = lloyd_relax(poly_map, 2)
 870:
import networkx
import itertools
import copy
 871:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 872:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 873:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 874:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 875:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 876:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 877:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 878:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 879:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 880:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 881:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 882:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 883:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 884:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 885:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 886: lloyd = lloyd_relax(poly_map, 2)
 887:
import networkx
import itertools
import copy
 888:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 889:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 890:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 891:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 892:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 893:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 894:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 895:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 896:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 897:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 898:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 899:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 900:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 901:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 902:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 903: lloyd = lloyd_relax(poly_map, 2)
 904:
import networkx
import itertools
import copy
 905:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 906:
itterations = 1

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 907:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 908:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 909:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 910:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 911:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 912:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 913:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])

plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 914:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 915:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = [::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 916:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 917:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 918:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 919:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 920:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 921:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 922:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 923: lloyd = lloyd_relax(poly_map, 2)
 924:
import networkx
import itertools
import copy
 925:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 926:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 927:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 928:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 929:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 930:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 931:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 932:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 933:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 934:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 935:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 936:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 937:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 938:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 939:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 940: lloyd = lloyd_relax(poly_map, 2)
 941:
import networkx
import itertools
import copy
 942:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 943:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 944:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 945:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 946:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 947:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 948:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 949:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 950:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 951:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 952:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 953:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 954:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 955:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 956:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 957: lloyd = lloyd_relax(poly_map, 2)
 958:
import networkx
import itertools
import copy
 959:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 960:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 961:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 962:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 963:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 964:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 965:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 966:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 967:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 968:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 969:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 970:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 971:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 972:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 973:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 974: lloyd = lloyd_relax(poly_map, 2)
 975:
import networkx
import itertools
import copy
 976:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 977:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 978:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 979:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 980:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 981:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 982:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
 983:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
 984:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
 985:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
 986:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
 987:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
 988:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
 989:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
 990:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
 991: lloyd = lloyd_relax(poly_map, 2)
 992:
import networkx
import itertools
import copy
 993:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
 994:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
 995:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
 996:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
 997:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
 998:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
 999:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1000:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

groups = collections.OrderedDict(sorted(groups.items()))
1001:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

ax.autoscale_view()
fig.set_size_inches(10, 10)
1002:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
1003:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

######

peaks_loc = PatchCollection(peak_check)
ax.add_collection(peaks_loc)
peaks_loc.set_color("#000000")

#####

ax.autoscale_view()
fig.set_size_inches(10, 10)
1004:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1005:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1006:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1007:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1008:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1009: lloyd = lloyd_relax(poly_map, 2)
1010:
import networkx
import itertools
import copy
1011:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1012:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1013:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
1014:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                elevation_decrease(n,new_cells,elevation-1)
1015:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1016:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1017:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1018:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

peak_check = []
for i in peaks_locs:
    peak_check.append(Polygon(lloyd.vertices[lloyd.regions[i]]))

groups = collections.OrderedDict(sorted(groups.items()))
1019:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

######

peaks_loc = PatchCollection(peak_check)
ax.add_collection(peaks_loc)
peaks_loc.set_color("#000000")

#####

ax.autoscale_view()
fig.set_size_inches(10, 10)
1020:

fig, ax = plt.subplots(1)
sea = []
collections = []
beach = []
mountains_top = []
for i in groups:
    if i > 25:
        sea.append(PatchCollection(groups[i]))
    elif i > 23:
        beach.append(PatchCollection(groups[i]))
    elif i > 10:
        collections.append(PatchCollection(groups[i]))
    else:
        mountains_top.append(PatchCollection(groups[i]))




for count,i in enumerate(sea):
    ax.add_collection(i)
    i.set_color([(0,0,20)])

beach_colours = ["#FFFFCC","#FFFF99"]
for count,i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for count,i in enumerate(collections):
    ax.add_collection(i)
    #print(200-count*2)
    i.set_color([(0,(200-count*5)/200,0)])
    #i.set_color([(0,0,0)])

mountains_top_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_top_colours = mountains_top_colours[::-1]
for count,i in enumerate(mountains_top):
    ax.add_collection(i)
    i.set_color(mountains_top_colours[count])
    #print(count)

ax.autoscale_view()
fig.set_size_inches(10, 10)
1021:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

######

peaks_loc = PatchCollection(peak_check)
#ax.add_collection(peaks_loc)
#peaks_loc.set_color("#000000")

#####

ax.autoscale_view()
fig.set_size_inches(10, 10)
1022:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

######

peaks_loc = PatchCollection(peak_check)
ax.add_collection(peaks_loc)
peaks_loc.set_color("#000000")

#####

ax.autoscale_view()
fig.set_size_inches(10, 10)
1023:
fig, ax = plt.subplots(1)
deep = []
water = []
hills = []
plains = []
beach = []
mountains = []

for i in groups:
    if i > 40:
        mountains.append(PatchCollection(groups[i]))
    elif i > 25:
        hills.append(PatchCollection(groups[i]))
    elif i > 10:
        plains.append(PatchCollection(groups[i]))
    elif i > 5:
        beach.append(PatchCollection(groups[i]))
    elif i > 0:
        water.append(PatchCollection(groups[i]))
    else:
        deep.append(PatchCollection(groups[i]))

mountains_colours = ["#FFFFFF","#F4F4F4","#F0F0F0","#E0E0E0","#D0D0D0","#C0C0C0","#B0B0B0","#A0A0A0","#909090","#808080","#707070","#606060","#505050","#404040","#303030","#303030","#303030"]
mountains_colours = mountains_colours[::-1]
for count, i in enumerate(mountains):
    ax.add_collection(i)
    i.set_color(mountains_colours[count])

hills_colours = ["#006600","#006600","#006600","#007600","#007600","#007600","#008600","#008600","#008600","#009600","#009600","#009600","#00A600","#00A600","#00A600"]
hills_colours = hills_colours[::-1]
for count, i in enumerate(hills):
    ax.add_collection(i)
    i.set_color(hills_colours[count])


plains_colours = [["#00AA00"],["#00AA00"],["#00AA00"],["#00AA00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00CC00"],["#00EE00"],["#00EE00"],["#00EE00"],["#00EE00"],["#33FF33"],["#33FF33"],["#33FF33"],["#33FF33"]]
plains_colours = plains_colours[::-1]
for count, i in enumerate(plains):
    ax.add_collection(i)
    i.set_color(plains_colours[count])

beach_colours = [["#FFFF66"],["#FFFF88"],["#FFFF88"],["#FFFFAA"],["#FFFFAA"]]
for count, i in enumerate(beach):
    ax.add_collection(i)
    i.set_color(beach_colours[count])

for i in water:
    ax.add_collection(i)
    i.set_color("#00FFFF")

for i in deep:
    ax.add_collection(i)
    i.set_color("#0000FF")

######

peaks_loc = PatchCollection(peak_check)
#ax.add_collection(peaks_loc)
#peaks_loc.set_color("#000000")

#####

ax.autoscale_view()
fig.set_size_inches(10, 10)
1024:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        height = random.randint(30,50)
        cell_network.nodes[peak]["height"] = height
        peaks_locs.append(peak)
1025:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1026:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1027:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1028:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1029:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1030: lloyd = lloyd_relax(poly_map, 2)
1031:
import networkx
import itertools
import copy
1032:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1033:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        height = random.randint(30,50)
        cell_network.nodes[peak]["height"] = height
        peaks_locs.append(peak)
1034:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
1035:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1036:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1037:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1038:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1039:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
1040:
itterations = 8

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1041:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
1042:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1043:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1044:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1045:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1046:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1047:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1048: lloyd = lloyd_relax(poly_map, 2)
1049:
import networkx
import itertools
import copy
1050:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1051:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1052:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
1053:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1054:
def elevation_decrease2(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if cell_network.nodes[n]["height"] < elevation:
            cell_network.nodes[n]["height"] = elevation
            new_cells.append(n)
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1055:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1056:
#print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1057:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1058:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

peak_check = []
for i in peaks_locs:
    peak_check.append(Polygon(lloyd.vertices[lloyd.regions[i]]))

groups = collections.OrderedDict(sorted(groups.items()))
1059:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1060:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1061:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1062:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1063:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1064: lloyd = lloyd_relax(poly_map, 2)
1065:
import networkx
import itertools
import copy
1066:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1067:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1068:
#print(peaks_locs[0])
#print("_____")
#
#cells_list = [peaks_locs[0]]
#for i in cell_network.neighbors(peaks_locs[0]):
#    print(i)
#    cells_list.append(i)
#
#print("_____")
#
#for i in cells_list:
#    for j in cell_network.neighbors(i):
#        if j not in cells_list:
#            print(j)
1069:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1070:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1071:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1072:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease2(peak,peaks_locs,cell_network.nodes[peak]["height"])
1073:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1074:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1075:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1076:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1077:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1078:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1079: lloyd = lloyd_relax(poly_map, 2)
1080:
import networkx
import itertools
import copy
1081:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1082:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1083:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1084:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1085:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1086:
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from matplotlib.patches import Polygon
import numpy as np
import random
1087:
size = 50
points = size*np.random.random((size**2,2))
poly_map = Voronoi(points)
1088:
#fig = voronoi_plot_2d(poly_map)
#fig.set_size_inches(20,20)
#fig.show()
1089:
def check(vertices):
    for couple in vertices:
        if (any(x < 0 or x > size for x in couple)):
            return False
    return True
1090:
def lloyd_relax(self, times):
        for i in range(times):
            centroids = []
            for region in self.regions:
                if (region != []):
                    vertices = self.vertices[region]
                    if (check(vertices)):
                        centroid_x = np.sum(vertices[:, 0])/vertices.shape[0]
                        centroid_y = np.sum(vertices[:, 1])/vertices.shape[0]
                        centroid = [centroid_x, centroid_y]
                        centroids.append(centroid)
            points = centroids
            vor = Voronoi(points)
        return vor
1091: lloyd = lloyd_relax(poly_map, 2)
1092:
import networkx
import itertools
import copy
1093:
cell_network = networkx.Graph()

edges = {}

for i, region in enumerate(lloyd.regions):
    for edge in list(itertools.combinations(region,2)):
        if edge in edges:
            edges[edge].append(i)
            edges[edge[::-1]].append(i)
        else:
            edges[edge] = [i]
            edges[edge[::-1]] = [i]

for i in edges:
    for j in edges[i]:
        cell_network.add_node(j,height = -10)
    if len(edges[i]) > 1:
        cell_network.add_edge(edges[i][0],edges[i][1])

#networkx.draw(cell_network)
1094:
itterations = 5

#peak generation
peaks_locs = []

for i in range(itterations):
    peak = random.randint(int(cell_network.number_of_nodes()*0.3),int(cell_network.number_of_nodes()*0.7))
    if check(lloyd.vertices[lloyd.regions[peak]]):
        cell_network.nodes[peak]["height"] = random.randint(30,50)
        peaks_locs.append(peak)
1095:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1096:
#for peak in peaks_locs:
    #print(peak, cell_network.nodes[peak]["height"])
1097:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1098:
def elevation_decrease(cell:int,complete_cells:list[int],elevation:int):
    print(cell)
    new_cells = copy.deepcopy(complete_cells)
    for n in cell_network.neighbors(cell):
        if (n not in new_cells):
            if cell_network.nodes[n]["height"] < elevation:
                cell_network.nodes[n]["height"] = elevation
                new_cells.append(n)
                
    for n in cell_network.neighbors(cell):
        elevation_decrease(n,new_cells,elevation-1)
1099:
print(peaks_locs)
for peak in peaks_locs: 
    elevation_decrease(peak,peaks_locs,cell_network.nodes[peak]["height"])
1100:
import collections
groups = {}

for i in cell_network.nodes:
    height = cell_network.nodes[i]["height"]
    if(check(lloyd.vertices[lloyd.regions[i]])):
        if height in groups:
            groups[height].append(Polygon(lloyd.vertices[lloyd.regions[i]]))
        else:
            groups[height] = [Polygon(lloyd.vertices[lloyd.regions[i]])]
#print(groups)

peak_check = []
for i in peaks_locs:
    peak_check.append(Polygon(lloyd.vertices[lloyd.regions[i]]))

groups = collections.OrderedDict(sorted(groups.items()))
1101: %history
1102: %history -g -f history.txt
